
<!-- originally posted at https://github.com/JorritSalverda/msbuild-by-convention/ -->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">

	<Import Project="properties-repository-specific.msbuild" />
	
	<!-- beginregion Build targets -->
	
	<Target Name="PrepareGlobalProperties">

		<ConvertToAbsolutePath Paths="$(SourceDirectory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteSourceDirectory" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(CloudExtensionsDir)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteCloudExtensionsDir" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(ExtensionTasksPath)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteExtensionTasksPath" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(SqlServerRedistPath)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteSqlServerRedistPath" />
		</ConvertToAbsolutePath>		
		<ConvertToAbsolutePath Paths="$(VSToolsPath)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteVSToolsPath" />
		</ConvertToAbsolutePath>		
		<ConvertToAbsolutePath Paths="$(BuildToolsDirectory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteBuildToolsDirectory" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(VisualStudioSqlServerDataToolsDir)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteVisualStudioSqlServerDataToolsDir" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(CommonTargetsExtensionFile)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteCommonTargetsExtensionFile" />
		</ConvertToAbsolutePath>		
		
		<PropertyGroup>
			<BuildParameters>$(BuildParameters);AbsoluteExtensionTasksPath=$(AbsoluteExtensionTasksPath);AbsoluteSourceDirectory=$(AbsoluteSourceDirectory);VSToolsPath=$(AbsoluteVSToolsPath);AbsoluteBuildToolsDirectory=$(AbsoluteBuildToolsDirectory);SsdtTargetsParentPath=$(AbsoluteVisualStudioSqlServerDataToolsDir);CommonTargetsExtensionFile=$(AbsoluteCommonTargetsExtensionFile)</BuildParameters>
			<BuildParameters Condition=" $(ReplaceSsdtImportStatement) == 'True' ">$(BuildParameters);SqlServerRedistPath=$(AbsoluteSqlServerRedistPath)</BuildParameters>			
			<BuildParameters Condition=" $(UseIncludedAzureSdkTargets) == 'True' ">$(BuildParameters);CloudExtensionsDir=$(AbsoluteCloudExtensionsDir)</BuildParameters>						
			<VersionedFilePostfix Condition=" '$(UseVersionedFiles)' == 'True' ">-$(BuildVersion)</VersionedFilePostfix>
		</PropertyGroup>
			
	</Target>
	
	<Target Name="CreateDirectories">
		<MakeDir Directories="@(DirectoriesToCreate)" />
	</Target>

	<Target Name="Clean" DependsOnTargets="CoreClean;CreateDirectories" />
	<Target Name="CoreClean">
		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToCreate.FullPath)" Condition=" Exists('%(DirectoriesToCreate.FullPath)') " />
		<RemoveDir Directories="@(DirectoriesToCreate)" />
	</Target>

	<Target Name="CopyDependencies">
		<ItemGroup>
			<DependenciesToCopy Include="$(DependencyDirectory)**\*.dll" />
			<DependenciesToCopy Include="$(DependencyDirectory)**\*.xml" />
		</ItemGroup>
		<Copy SourceFiles="@(DependenciesToCopy)" DestinationFolder="$(BinDirectory)" Condition=" @(DependenciesToCopy) != '' And $(CopyDependenciesToBinFolder) == 'True' " />
	</Target>
	
	<Target Name="SetAssemblyFileVersion">
		<!-- set correct file version -->
		<ItemGroup>
			<AssemblyInfoFiles Include="$(CSharpSourceDirectory)**\AssemblyInfo.cs" />
		</ItemGroup>
		<Attrib ReadOnly="false" Files="@(AssemblyInfoFiles)" />
	    <FileUpdate Files="@(AssemblyInfoFiles)" Regex="\[\s*assembly\s*:\s*AssemblyVersion\s*\(\s*&quot;[\d\.\*]+&quot;\s*\)\s*\]" ReplacementText="[assembly: AssemblyVersion(&quot;$(BuildVersion)&quot;)]" Condition=" @(AssemblyInfoFiles) != '' " />
	    <FileUpdate Files="@(AssemblyInfoFiles)" Regex="\[\s*assembly\s*:\s*AssemblyFileVersion\s*\(\s*&quot;[\d\.\*]+&quot;\s*\)\s*\]" ReplacementText="[assembly: AssemblyFileVersion(&quot;$(BuildVersion)&quot;)]" Condition=" @(AssemblyInfoFiles) != '' " />
	</Target>

	<Target Name="ReplaceProjectImportStatements" Condition=" Exists('$(VisualStudioSqlServerDataToolsDir)Microsoft.Data.Tools.Schema.SqlTasks.targets') ">
		<!-- look for sqlproj files and replace the import statement with one pointing to /build/tools/VisualStudio.v11.0/SSDT -->
		<ItemGroup>
			<DbProjectFiles Remove="@(DbProjectFiles)" />
			<DbProjectFiles Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).sqlproj" Condition=" $(ReplaceSsdtImportStatement) == 'True' " />
		</ItemGroup>
		
		<!-- keep backup of the project file -->
		<Copy SourceFiles="@(DbProjectFiles)" DestinationFiles="%(DbProjectFiles.FullPath).original" /> 
		
		<Attrib ReadOnly="false" Files="@(DbProjectFiles)" />
	    <FileUpdate Files="@(DbProjectFiles)" Regex="\$\(MSBuildExtensionsPath\)\\Microsoft\\VisualStudio\\v\$\(VisualStudioVersion\)\\SSDT\\" ReplacementText="$(AbsoluteVisualStudioSqlServerDataToolsDir)" Condition=" @(DbProjectFiles) != '' " />
	
	</Target>
	
	<Target Name="Compile" DependsOnTargets="Clean;CopyDependencies;SetAssemblyFileVersion;ReplaceProjectImportStatements;BeforeCompile;CoreCompile;AfterCompile" />
	<Target Name="BeforeCompile">
	
		<CallTarget Targets="CheckJavascriptWithJsHint" Condition=" $(CheckJavascriptOnBuild) == 'True' " />
	
		<!-- solutions that have a dependency order are specified in properties-repository-specific.msbuild; over here we add all solutions so it's not neccessary to list them all in properties-repository-specific.msbuild -->
		<ItemGroup>
			<SolutionsToBuild Include="$(CSharpSourceDirectory)**\*.sln" />
		</ItemGroup>
		
		<Delete Files="$(BuildVersionFilePath)" Condition=" Exists('$(BuildVersionFilePath)') " />
				
	</Target>
    <Target Name="CoreCompile" Inputs="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)" Outputs="NonExistingOutputToTriggerTargetForEverySolution">
		<Error Text="There are no solutions to compile!" Condition=" @(SolutionsToBuild) == '' " />

		<!-- build solution -->
		<MSBuild Projects="%(SolutionsToBuild.FullPath)" Targets="$(CompileTarget)" Properties="$(BuildParameters)" BuildInParallel="true">
			<Output TaskParameter="TargetOutputs" ItemName="BuildOutput" />
		</MSBuild>

		<!-- compile views for all website and webservice projects -->
		<ItemGroup>
			<ProjectsToBuild Include="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)**\*.$(WebsiteProjectConventionName).csproj" />
			<ProjectsToBuild Include="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)**\*.$(WebServiceProjectConventionName).csproj" />
		</ItemGroup>

		<!-- remove obj directory from build directory, otherwise aspnetcompiler might fail due to multiple web.configs -->
		<ItemGroup>
			<DirectoriesToRemove Remove="@(DirectoriesToRemove)" />
			<DirectoriesToRemove Include="%(ProjectsToBuild.RelativeDir)obj" />
		</ItemGroup>

		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToRemove.FullPath)" Condition=" Exists('%(DirectoriesToRemove.FullPath)') " />
		<RemoveDir Directories="@(DirectoriesToRemove)" />
		
		<AspNetCompiler VirtualPath="/" PhysicalPath="%(ProjectsToBuild.RelativeDir)" Condition=" Exists('%(ProjectsToBuild.RelativeDir)Web.config') " />

		<!-- copy output assemblies to build/bin directory -->
        <Copy SourceFiles="@(BuildOutput)" DestinationFolder="$(BinDirectory)" Condition = "%(Extension) == '.dll' Or %(Extension) == '.xml'" />
    </Target>	
	<Target Name="AfterCompile">
	
		<!-- restore db project file -->
		<ItemGroup>
			<_OriginalDbProjectFiles Remove="@(_OriginalDbProjectFiles)" />
			<_OriginalDbProjectFiles Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).sqlproj.original" />
			
			<OriginalDbProjectFiles Remove="@(OriginalDbProjectFiles)" />
			<OriginalDbProjectFiles Include="%(_OriginalDbProjectFiles.FullPath)">
				<DestinationFile>$([System.String]::Copy('%(_OriginalDbProjectFiles.FullPath)').Replace(".original",""))</DestinationFile>
			</OriginalDbProjectFiles>
		</ItemGroup>
		
		<Message Text="OriginalDbProjectFiles: @(OriginalDbProjectFiles)" />

		<Copy SourceFiles="@(OriginalDbProjectFiles)" DestinationFiles="%(OriginalDbProjectFiles.DestinationFile)" />
		<Delete Files="@(OriginalDbProjectFiles)" />

		<!-- indicates which version has been built last in order to do a compile check -->
		<WriteLinesToFile File="$(BuildVersionFilePath)" Lines="$(BuildVersion)" Overwrite="true" />

	</Target>	
	
	<Target Name="CheckJavascriptWithJsHint">

		<ItemGroup>
			<!-- check all javascript files except for the ones where the filename ends in .min.js -->
			<JavaScriptFiles Include="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\**\*.js" Exclude="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\**\*.min.js;$(SourceDirectory)**\obj\**\*.js;$(SourceDirectory)**\csx\**\*.js" />
		</ItemGroup>
	
		<Exec Command="cscript &quot;$(JSHintPath)&quot; %(JavaScriptFiles.RelativeDir)%(JavaScriptFiles.Filename)%(JavaScriptFiles.Extension)" />		
		
	</Target>	
	
	<Target Name="CompileCheck">
		
		<PropertyGroup>
			<BuildVersionFromFile></BuildVersionFromFile>
		</PropertyGroup>
		
		<ReadLinesFromFile File="$(BuildVersionFilePath)" Condition=" Exists('$(BuildVersionFilePath)') " >
            <Output TaskParameter="Lines" ItemName="BuildVersionFromFile"/>
        </ReadLinesFromFile>
		
		<Message Text="Same version, no need to compile" Importance="High" Condition=" @(BuildVersionFromFile) == $(BuildVersion) " />
		<Message Text="Other version, compile first" Importance="High" Condition=" @(BuildVersionFromFile) != $(BuildVersion) " />
		
		<CallTarget Targets="Compile" Condition=" @(BuildVersionFromFile) != $(BuildVersion) " />
		<CallTarget Targets="SetAssemblyFileVersion" Condition=" @(BuildVersionFromFile) == $(BuildVersion) " />
		
	</Target>

	<!-- endregion Build targets -->

	<!-- beginregion Tests targets -->
	
	<Target Name="RunUnitTests" DependsOnTargets="PrepareGlobalProperties;CompileCheck;CreateDirectories;BeforeRunUnitTests;CoreRunTests" />
	<Target Name="BeforeRunUnitTests">
		<ItemGroup>
			<TestProjects Include="$(CSharpSourceDirectory)**\*.$(UnitTestsProjectConventionName).csproj" />
		</ItemGroup>	
	</Target>
	
	<Target Name="RunIntegrationTests" DependsOnTargets="PrepareGlobalProperties;CompileCheck;CreateDirectories;BeforeRunIntegrationTests;CoreRunTests" />
	<Target Name="BeforeRunIntegrationTests">
		<ItemGroup>
			<TestProjects Include="$(CSharpSourceDirectory)**\*.$(IntegrationTestsProjectConventionName).csproj" />
		</ItemGroup>	
	</Target>	
	
	<Target Name="CoreRunTests">
	
		<Delete Files="$(TestResultsDirectory)*" />
		<Delete Files="$(CodeCoverageDirectory)*" />

		<ItemGroup>
			<TestAssemblies Remove="@(TestAssemblies)" />
			<TestAssemblies Include="%(TestProjects.RelativeDir)bin\$(Configuration)\%(TestProjects.Filename).dll" />
			<AssembliesToReportCoverage Remove="@(AssembliesToReportCoverage)" />
			<AssembliesToReportCoverage Include="$(CSharpSourceDirectory)**\*.csproj" Exclude="$(CSharpSourceDirectory)**\*.$(UnitTestsProjectConventionName).csproj;$(CSharpSourceDirectory)**\*.$(IntegrationTestsProjectConventionName).csproj" />
		</ItemGroup>		

		<PropertyGroup>
			<OpenCoverFilter>+[@(AssembliesToReportCoverage -> '%(Filename)', ']* +[')]*</OpenCoverFilter>
		</PropertyGroup>		
		
		<!-- filter out test assemblies if nunit.framework.dll is not referenced -->
		<ItemGroup>
			<NunitTestAssemblies Remove="@(NunitTestAssemblies)" />
			<NunitTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)nunit.framework.dll') " />
		</ItemGroup>

		<!-- run tests if coverage is disabled -->
		<NUnit Assemblies="@(NunitTestAssemblies)" ToolPath="$(NUnitToolPath)" OutputXmlFile="$(TestResultsDirectory)NUnit.Results.%(NunitTestAssemblies.Filename).xml" DisableShadowCopy="true" Condition=" @(NunitTestAssemblies) != '' And $(IncludeCoverage) == 'False' " ContinueOnError="$(ContinueOnTestError)" />
		
		<!-- run tests with coverage (https://github.com/sawilde/opencover/wiki/Usage) -->
		<Exec Command="$(OpenCoverPath)OpenCover.Console.exe -register:user -returntargetcode -target:$(NUnitToolPath)nunit-console.exe -targetargs:&quot;@(NunitTestAssemblies -> '%(FullPath)', ' ') /result=$(TestResultsDirectory)NUnit.Results.%(NunitTestAssemblies.Filename).xml /noshadow&quot; -filter:&quot;$(OpenCoverFilter)&quot; -output:$(CodeCoverageDirectory)NUnit.Coverage.%(NunitTestAssemblies.Filename).xml" Condition=" @(NunitTestAssemblies) != '' And $(IncludeCoverage) == 'True' " ContinueOnError="$(ContinueOnTestError)" />
			
			
			
		<!-- filter out test assemblies if Machine.Specifications.dll is not referenced -->
		<ItemGroup>
			<MSpecTestAssemblies Remove="@(MSpecTestAssemblies)" />
			<MSpecTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)Machine.Specifications.dll') " />
		</ItemGroup>

		<!-- run tests if coverage is disabled -->
		<Exec Command="$(MSpecRunnerPath) --xml $(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml @(MSpecTestAssemblies -> '%(Identity)', ' ')" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'False' " IgnoreExitCode="$(ContinueOnTestError)" />

		<!-- transform mspec xml to junit xml (https://gist.github.com/Kyrodan/1183475) -->		
		<XslTransformation  XmlInputPaths="$(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml" XslInputPath="$(MSpecToJUnitXsltPath)" OutputPaths="$(TestResultsDirectory)MSpec.Results.%(MSpecTestAssemblies.Filename).xml" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'False' " />
		<Delete Files="$(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'False' " />
		
		<!-- run tests with coverage (https://github.com/sawilde/opencover/wiki/Usage) -->
		<Exec Command="$(OpenCoverPath)OpenCover.Console.exe -register:user -returntargetcode -target:$(MSpecRunnerPath) -targetargs:&quot;--xml $(TestResultsDirectory)MSpecTemp.Results.%(MSpecTestAssemblies.Filename).xml @(MSpecTestAssemblies -> '%(Identity)', ' ')&quot; -filter:&quot;$(OpenCoverFilter)&quot; -output:$(CodeCoverageDirectory)MSpec.Coverage.%(MSpecTestAssemblies.Filename).xml" Condition=" @(MSpecTestAssemblies) != '' And $(IncludeCoverage) == 'True' " ContinueOnError="$(ContinueOnTestError)" />
			
			
			
		<!-- filter out test assemblies if Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll is not referenced -->
		<ItemGroup>
			<MSTestTestAssemblies Remove="@(MSTestTestAssemblies)" />
			<MSTestTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll') " />
		</ItemGroup>

		<!-- run tests if coverage is disabled -->
		<Exec Command="$(MSTestRunnerPath) /testcontainer:%(MSTestTestAssemblies.Identity) /resultsfile:$(TestResultsDirectory)MsTest.%(MSTestTestAssemblies.Filename).Results.xml /nologo" Condition=" @(MSTestTestAssemblies) != '' And $(IncludeCoverage) == 'False' " IgnoreExitCode="$(ContinueOnTestError)" />

		<!-- run tests with coverage (https://github.com/sawilde/opencover/wiki/Usage) -->
		<Exec Command="$(OpenCoverPath)OpenCover.Console.exe -register:user -returntargetcode -target:$(MSTestRunnerPath) -targetargs:&quot;/testcontainer:%(MSTestTestAssemblies.Identity) /resultsfile:$(TestResultsDirectory)MsTest.%(MSTestTestAssemblies.Filename).Results.xml /nologo&quot; -filter:&quot;$(OpenCoverFilter)&quot; -output:$(CodeCoverageDirectory)MSTest.Coverage.%(MSTestTestAssemblies.Filename).xml" Condition=" @(MSTestTestAssemblies) != '' And $(IncludeCoverage) == 'True' " ContinueOnError="$(ContinueOnTestError)" />
		
		
		<!-- convert coverage xml to html report (http://reportgenerator.codeplex.com/) -->
		<Exec Command="&quot;$(ReportGeneratorPath)ReportGenerator.exe&quot; &quot;-reports:$(CodeCoverageDirectory)\*.xml&quot; &quot;-targetdir:$(CodeCoverageDirectory)\&quot; -reporttypes:Html;HtmlSummary" Condition=" ( @(NunitTestAssemblies) != '' Or @(MSpecTestAssemblies) != '' Or @(MSTestTestAssemblies) != '' ) And $(IncludeCoverage) == 'True' " />
		
	</Target>
	
	<Target Name="RunYSlowTests">

		<Exec Command="&quot;$(PhantomJsPath)&quot; &quot;$(YSlowPath)&quot; -i grade -threshold '$(YSlowTreshold)' -f junit $(YSlowTestUrl) > $(TestResultsDirectory)yslow.xml"/>
	
	</Target>
	
	<!-- endregion Tests targets -->
			
	<!-- beginregion RunJMeterTests targets -->
	
	<Target Name="RunJMeterTests" DependsOnTargets="BeforeRunJMeterTests;CoreRunJMeterTests" />
	<Target Name="BeforeRunJMeterTests">
		<ItemGroup>
			<JMeterTestProjects Remove="@(JMeterTestProjects)" />
			<JMeterTestProjects Include="$(JMeterTestsDirectory)**\*.jmx" />
		</ItemGroup>
	</Target>
	<Target Name="CoreRunJMeterTests" Inputs="%(JMeterTestProjects.FullPath)" Outputs="AlwaysExecute">
		<ConvertToAbsolutePath Paths="$(TestResultsDirectory)%(JMeterTestProjects.Filename).log">
			<Output TaskParameter="AbsolutePaths" PropertyName="JMeterTestLogFileLocation" />
		</ConvertToAbsolutePath>

		<ConvertToAbsolutePath Paths="$(TestResultsDirectory)%(JMeterTestProjects.Filename).jtl">
			<Output TaskParameter="AbsolutePaths" PropertyName="JMeterTestOutputFileLocation" />
		</ConvertToAbsolutePath>

		<!-- start non-gui version of jmeter and pass jmx file, test output location and log file output location -->
		<Exec Command="$(JMeterToolPath) -n -t %(JMeterTestProjects.FullPath) -l $(JMeterTestOutputFileLocation) -j $(JMeterTestLogFileLocation)" Condition=" @(JMeterTestProjects) != '' " />

		<Message Text="##teamcity[importData type='junit' path='$(JMeterTestOutputFileLocation)']" />
	</Target>
	
	<!-- endregion RunJMeterTests targets -->	
	
	<!-- beginregion Release targets -->	

	<Target Name="MinifyJavaScript" DependsOnTargets="BeforeMinifyJavaScript;CoreMinifyJavaScript" />
	<Target Name="BeforeMinifyJavaScript">
		<!-- remove previously minified javascript -->
		<ItemGroup>
			<OldJavaScriptFiles Include="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\*.min.js" />
		</ItemGroup>
		<Delete Files="@(OldJavaScriptFiles)" />

		<ItemGroup>
			<JavaScriptFiles Remove="@(JavaScriptFiles)" />
			<JavaScriptFiles Include="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\**\*.js" Exclude="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\*.min.js" />
			<!-- do not include js files in the js 'root'; put your code in subdirs -->
			<JavaScriptFiles Remove="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\*.js" />
		</ItemGroup>
	</Target>
	<Target Name="CoreMinifyJavaScript" Inputs="%(JavaScriptFiles.RootDir)%(JavaScriptFiles.Directory)" Outputs="AlwaysExecute">
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="%(JavaScriptFiles.Directory)" String2="\">
			<Output ItemName="JavaScriptOutputDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(JavaScriptOutputDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="JavaScriptSubDirectory" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<JavaScriptCompressorTask
			SourceFiles="@(JavaScriptFiles)"
			OutputFile="%(JavaScriptFiles.RootDir)%(JavaScriptFiles.Directory)..\@(JavaScriptSubDirectory)$(VersionedFilePostfix).min.js"
			ObfuscateJavaScript="True"
			PreserveAllSemicolons="False"
			DisableOptimizations="False"
			EncodingType="UTF8"
			DeleteSourceFiles="false"
			LineBreakPosition="-1"
			LoggingType="Info"
			ThreadCulture="en-US"
			IsEvalIgnored="false"
			/>
	</Target>

	<Target Name="MinifyCss" DependsOnTargets="BeforeMinifyCss;CoreMinifyCss" />
	<Target Name="BeforeMinifyCss">
		<!-- remove previously minified css -->
		<ItemGroup>
			<OldCssFiles Include="$(SourceDirectory)**\$(CssDirectoryConventionName)\**\*.min.css" />
		</ItemGroup>
		<Delete Files="@(OldCssFiles)" />

		<ItemGroup>
			<CssFiles Remove="@(CssFiles)" />
			<CssFiles Include="$(SourceDirectory)**\$(CssDirectoryConventionName)\**\*.css" Exclude="$(SourceDirectory)**\$(CssDirectoryConventionName)\**\*.min.css" />
			<!-- do not include css files in the css 'root'; put your code in subdirs (it should only contain stuff like _constants.scss) -->
			<CssFiles Remove="$(SourceDirectory)**\$(CssDirectoryConventionName)\*.css" />
		</ItemGroup>
	</Target>
	<Target Name="CoreMinifyCss" Inputs="%(CssFiles.RootDir)%(CssFiles.Directory)" Outputs="AlwaysExecute">
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="%(CssFiles.Directory)" String2="\">
			<Output ItemName="CssOutputDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(CssOutputDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="CssSubDirectory" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<CssCompressorTask
			SourceFiles="@(CssFiles)"
			OutputFile="%(CssFiles.RootDir)%(CssFiles.Directory)@(CssSubDirectory)$(VersionedFilePostfix).min.css"
			CompressionType="Standard"
			EncodingType="UTF8"
			DeleteSourceFiles="false"
			LineBreakPosition="-1"
			LoggingType="Info"
			/>
	</Target>

	<Target Name="PublishFlash" DependsOnTargets="BeforePublishFlash;CorePublishFlash" />
	<Target Name="BeforePublishFlash">
		<ItemGroup>
			<FlashProjects Include="$(FlashSourceDirectory)**\*.$(FlashProjectDirectoryConventionName)\*" />
			<FlashProjectDirs Include="@(FlashProjects->'%(RelativeDir)')" />
		</ItemGroup>
	</Target>
	<Target Name="CorePublishFlash" Inputs="%(FlashProjectDirs.RootDir)%(FlashProjectDirs.Directory)" Outputs="AlwaysExecute">
		<!-- get rid of the trailing slash -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Replace" OldString="%(FlashProjectDirs.RelativeDir)\" OldValue="\\" NewValue="">
            <Output PropertyName="TrimmedFlashProjectDirectory" TaskParameter="NewString" />
        </MSBuild.ExtensionPack.Framework.TextString>

		<!-- get the last directory name -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(TrimmedFlashProjectDirectory)" String2="\">
			<Output ItemName="FlashProjectDirsParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(FlashProjectDirsParts)">
            <Output TaskParameter="OutputItems" ItemName="FlashProjectDirNameOutput" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
		<PropertyGroup>
			<FlashProjectDirName>@(FlashProjectDirNameOutput)</FlashProjectDirName>
		</PropertyGroup>

		<!-- resolve the same directory tree within SourceDirectory -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Replace" OldString="%(FlashProjectDirs.RelativeDir)" OldValue="$(FlashSourceDirectory)" NewValue="$(CSharpSourceDirectory)">
            <Output PropertyName="RelativeSwfTargetDirectory" TaskParameter="NewString" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<ConvertToAbsolutePath Paths="$(RelativeSwfTargetDirectory)../">
			<Output TaskParameter="AbsolutePaths" PropertyName="SwfTargetDirectory" />
		</ConvertToAbsolutePath>

        <Error Text="Target path $(SwfTargetDirectory) doesn't exists. Put your as3proj file in a similar directory structure inside $(FlashSourceDirectory) as the one in $(CSharpSourceDirectory) to publish to." Condition=" !Exists('$(SwfTargetDirectory)') " />

		<PropertyGroup>
			<SwfTargetFile>$(SwfTargetDirectory)$(FlashProjectDirName)$(VersionedFilePostfix).swf</SwfTargetFile>
		</PropertyGroup>

		<Message Text="Publishing %(FlashProjectDirs.RelativeDir) to $(SwfTargetFile)" Importance="high" />

		<ConvertToAbsolutePath Paths="%(FlashProjectDirs.RootDir)%(FlashProjectDirs.Directory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="WorkingDir" />
		</ConvertToAbsolutePath>

		<PropertyGroup>
			<BuildPropertiesFile>%(FlashProjectDirs.RootDir)%(FlashProjectDirs.Directory)build-properties.xml</BuildPropertiesFile>
		</PropertyGroup>

		<!-- fetch flash project specific variables from build-properties.xml -->
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashAutoBuild[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashAutoBuild" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashCompilerLocale[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashCompilerLocale" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashCompilerAS3[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashCompilerAS3" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashCompilerStrict[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashCompilerStrict" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashCompilerDebug[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashCompilerDebug" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashCompilerOptimize[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashCompilerOptimize" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashCompilerSwfVersion[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashCompilerSwfVersion" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashCompilerTargetPlayer[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashCompilerTargetPlayer" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashSrcDirectories/FlashSrcDirectory/text()">
			<Output TaskParameter="Result" ItemName="FlashSrcDirectories" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashEntryPointFile[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashEntryPointFile" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashBackgroundColor[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashBackgroundColor" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashFrameRate[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashFrameRate" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashWidth[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashWidth" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashHeight[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashHeight" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashLibs/FlashLib/text()">
			<Output TaskParameter="Result" ItemName="FlashLibs" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashMetaDataTags/FlashMetaDataTag/text()">
			<Output TaskParameter="Result" ItemName="FlashMetaDataTags" />
		</XmlPeek>

		<!-- remove old versions of published swfs -->
		<ItemGroup>
			<OldSwfsToDelete Remove="@(OldSwfsToDelete)" />
			<OldSwfsToDelete Include="$(SwfTargetDirectory)$(FlashProjectDirName).*.swf" />
		</ItemGroup>

		<Delete Files="@(OldSwfsToDelete)" Condition=" @(FlashAutoBuild) != 'False' " />

		<!-- compile flash and output to SwfTargetFile -->
		<Exec WorkingDirectory="$(WorkingDir)" Command="&quot;$(FlexSdkPath)&quot; -tools-locale=@(FlashCompilerLocale) -as3=@(FlashCompilerAS3) -strict=@(FlashCompilerStrict) -debug=@(FlashCompilerDebug) -optimize=@(FlashCompilerOptimize) -swf-version=@(FlashCompilerSwfVersion) -target-player=@(FlashCompilerTargetPlayer) -default-frame-rate=@(FlashFrameRate) -default-background-color=@(FlashBackgroundColor) -default-size=@(FlashWidth),@(FlashHeight) -source-path+=@(FlashSrcDirectories,' -source-path+=') -library-path+=@(FlashLibs,' -library-path+=') -keep-as3-metadata+=@(FlashMetaDataTags,' -keep-as3-metadata+=') -file-specs=$(WorkingDir)@(FlashEntryPointFile) -output=$(SwfTargetFile) -use-network=true -static-link-runtime-shared-libraries=true" CustomWarningRegularExpression="Warning|Waarschuwing" CustomErrorRegularExpression="Error|Fout" Condition=" @(FlashAutoBuild) != 'False' " />
		
	</Target>
	
	<Target Name="BeforeRelease">
		<!-- remove all release artifacts from previous releases -->
		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="$(ReleaseDirectory)" Condition=" Exists('$(ReleaseDirectory)') " />

		<!-- make sure we do a 'rebuild' instead of 'build' -->
		<PropertyGroup>
			<CompileTarget>Clean;Rebuild</CompileTarget>
		</PropertyGroup>
		
		<ItemGroup>
			<AllEnvironmentsToRelease Remove="@(AllEnvironmentsToRelease)" />
		</ItemGroup>	
		
	</Target>

	<Target Name="ReleaseWebsites">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WebsiteProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>True</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern></FilesToCopyForReleasePattern>
				<TargetConfigExtension>dll.config</TargetConfigExtension>
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseWebServices">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WebServiceProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>True</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern></FilesToCopyForReleasePattern>
				<TargetConfigExtension>dll.config</TargetConfigExtension>
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>
	
	<Target Name="ReleaseStaticHtml">
		<ItemGroup>
			<ProjectsToRelease Include="$(HtmlSourceDirectory)**\*.$(StaticHtmlProjectConventionName)\index.html">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>**\*</FilesToCopyForReleasePattern>				
				<TargetConfigExtension>dll.config</TargetConfigExtension>
			</ProjectsToRelease>			
		</ItemGroup>	
	</Target>	

	<Target Name="ReleaseConsoleApps">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(ConsoleAppProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
				<TargetConfigExtension>exe.config</TargetConfigExtension>
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseServices">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WindowsServiceProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
				<TargetConfigExtension>exe.config</TargetConfigExtension>
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseWorkers">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WorkerProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
				<TargetConfigExtension>dll.config</TargetConfigExtension>
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseDatabases">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).dbproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>sql\$(Configuration)\*</FilesToCopyForReleasePattern>
			</ProjectsToRelease>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).sqlproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
			</ProjectsToRelease>
		</ItemGroup>			
	</Target>
	
	<Target Name="CoreRelease" Inputs="%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)%(ProjectsToRelease.Environment)" Outputs="AlwaysExecute">
		<PropertyGroup>
			<ProjectSourceDirectory>%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)</ProjectSourceDirectory>
			<UseAspNetCompilerForRelease>%(ProjectsToRelease.UseAspNetCompilerForRelease)</UseAspNetCompilerForRelease>
			<FilesToCopyForReleasePattern>%(ProjectsToRelease.FilesToCopyForReleasePattern)</FilesToCopyForReleasePattern>
		</PropertyGroup>

		<ItemGroup>
			<ProjectName Remove="@(ProjectName)" />
		</ItemGroup>
		
		<!-- get project name -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(ProjectSourceDirectory)" String2="\">
			<Output ItemName="ProjectSourceDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(ProjectSourceDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="ProjectName" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>			

		<PropertyGroup>
			<ProjectName>@(ProjectName)</ProjectName>
			<RelativeProjectReleaseDirectory>$(ProjectName)\</RelativeProjectReleaseDirectory>
		</PropertyGroup>			
		
		<!-- resolve the temporary release directory -->
		<ConvertToAbsolutePath Paths="$(ReleaseTempDirectory)$(RelativeProjectReleaseDirectory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="ProjectReleaseDirectory" />
		</ConvertToAbsolutePath>

		<!-- remove obj directory from build directory, otherwise aspnetcompiler might fail due to multiple web.configs -->
		<ItemGroup>
			<DirectoriesToRemove Remove="@(DirectoriesToRemove)" />
			<DirectoriesToRemove Include="%(ProjectsToRelease.RelativeDir)obj" />
		</ItemGroup>		

		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToRemove.FullPath)" Condition=" Exists('%(DirectoriesToRemove.FullPath)') " />
		<RemoveDir Directories="@(DirectoriesToRemove)" />
		
		<!-- if it has a web.config let aspnetcompiler precompile the project  -->
		<AspNetCompiler VirtualPath="/" PhysicalPath="$(ProjectSourceDirectory)" TargetPath="$(ProjectReleaseDirectory)" Updateable="$(CreateUpdateableAspxFilesInRelease)" Condition=" $(UseAspNetCompilerForRelease) == 'True' " />
	
		<!-- otherwise copy the files and dirs defined in FilesToCopyForReleasePattern to the temp folder -->
		<ItemGroup>
			<FilesToCopy Remove="@(FilesToCopy)" />
			<FilesToCopy Include="$(ProjectSourceDirectory)$(FilesToCopyForReleasePattern)" Condition=" $(FilesToCopyForReleasePattern) != '' " />
		</ItemGroup>
		<Copy SourceFiles="@(FilesToCopy)" DestinationFolder="$(ProjectReleaseDirectory)%(FilesToCopy.RecursiveDir)" Condition=" @(FilesToCopy) != '' " />	
		
		<!-- remove project files and web.config transform files from release directory -->
		<ItemGroup>
			<FilesToRemoveFromReleaseDirectory Remove="@(FilesToRemoveFromReleaseDirectory)" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.csproj*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)packages.config" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.settings" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.scss" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.*.config" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.snk" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)obj\**\*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)_ReSharper*\**\*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*ReSharper*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.sln" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\.svn\**\*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\.sonar\**\*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.sublime-*" />			
		</ItemGroup>
		<Delete Files="@(FilesToRemoveFromReleaseDirectory)" />

		<!-- update version number inside js and css files -->
		<ItemGroup>
			<AllStaticFiles Remove="@(AllStaticFiles)" />
			<AllStaticFiles Include="$(ProjectReleaseDirectory)$(CssDirectoryConventionName)\**\*.css" />
			<AllStaticFiles Include="$(ProjectReleaseDirectory)$(JavascriptDirectoryConventionName)\**\*.js" />
			<AllStaticFiles Include="$(ProjectReleaseDirectory)**\*.html" />
		</ItemGroup>
		
		<Attrib ReadOnly="false" Files="@(AllStaticFiles)" />
	    <FileUpdate Files="@(AllStaticFiles)" Regex="1\.0\.0\.0" ReplacementText="$(BuildVersion)" Condition=" @(AllStaticFiles) != '' " />
	
		<!-- remove debug sections -->
		<FileUpdate Files="@(AllStaticFiles)" Regex="(&lt;!-- begin debug --&gt;.*?&lt;!-- end debug --&gt;)|(&lt;!-- begin release)|(end release --&gt;)" ReplacementText=" " Singleline="True" Multiline="True" Condition=" @(AllStaticFiles) != '' " />		
		
		<!-- optimize all jpegs -->
		<ItemGroup>
			<AllJpegFiles Remove="@(AllJpegFiles)" />
			<AllJpegFiles Include="$(ProjectReleaseDirectory)**\*.jpg" />
			<AllJpegFiles Include="$(ProjectReleaseDirectory)**\*.jpeg" />
		</ItemGroup>
		<Exec Command="&quot;$(JpegtranPath)&quot; -progressive -optimize &quot;%(AllJpegFiles.FullPath)&quot; &quot;%(AllJpegFiles.FullPath)&quot;" Condition=" @(AllJpegFiles) != '' And $(OptimizeImages) " />

		<!-- optimize all pngs -->
		<ItemGroup>
			<AllPngFiles Remove="@(AllPngFiles)" />
			<AllPngFiles Include="$(ProjectReleaseDirectory)**\*.png" />
		</ItemGroup>
		<Exec Command="&quot;$(OptiPngPath)&quot; &quot;%(AllPngFiles.FullPath)&quot;" Condition=" @(AllPngFiles) != '' And $(OptimizeImages) " />

		<!-- determine all environments from *.*.config -->
		<ItemGroup>
			<AllEnvironmentTransforms Remove="@(AllEnvironmentTransforms)" />
			<AllEnvironmentTransforms Include="$(ProjectSourceDirectory)*.*.config" />

			<__AllEnvironments Remove="@(__AllEnvironments)" />
			<__AllEnvironments Include="$(SuitedForAllEnvironmentsDirectoryName)" Condition=" @(AllEnvironmentTransforms) == '' " />
			<__AllEnvironments Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[1])" Condition=" @(AllEnvironmentTransforms) != '' " />
			<_AllEnvironments Remove="@(AllEnvironments)" />
			<AllEnvironments Remove="@(AllEnvironments)" />
			
			<_AllConfigsWithTransforms Remove="@(_AllConfigsWithTransforms)" />
			<_AllConfigsWithTransforms Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[0])" Condition=" @(AllEnvironmentTransforms) != '' " />
			<AllConfigsWithTransforms Remove="@(AllConfigsWithTransforms)" />
		</ItemGroup>
		
		<!-- remove duplicates -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(__AllEnvironments)">
            <Output TaskParameter="OutputItems" ItemName="_AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(_AllConfigsWithTransforms)" Condition=" @(_AllConfigsWithTransforms) != '' ">
            <Output TaskParameter="OutputItems" ItemName="AllConfigsWithTransforms"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<!--  remove environments that are not in @(ConfigurationsToRelease) -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetCommonItems" InputItems1="@(_AllEnvironments)" InputItems2="@(ConfigurationsToRelease)" Condition=" @(ConfigurationsToRelease) != '' " >
            <Output TaskParameter="OutputItems" ItemName="AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
		<!--  or keep all environments if @(ConfigurationsToRelease) is empty -->
		<ItemGroup>
			<AllEnvironments Include="@(_AllEnvironments)" Condition=" @(ConfigurationsToRelease) == '' " />
			<AllEnvironmentsToRelease Include="@(AllEnvironments)" />
		</ItemGroup>

		<ItemGroup>
			<ConfigsToTransform Remove="@(ConfigsToTransform)" />
			<ConfigsToTransform Include="@(AllConfigsWithTransforms)">
				<Environment>%(AllEnvironments.Identity)</Environment>
			</ConfigsToTransform>
		</ItemGroup>

		<!-- copy everything from temp directory to release directory and then remove temp directory; this is to ensure no empty directories end up in the release -->
		<ItemGroup>
			<FilesToMove Remove="@(FilesToMove)" />
			<FilesToMove Include="$(ReleaseTempDirectory)**">
				<Environment>%(AllEnvironments.Identity)</Environment>
			</FilesToMove>
		</ItemGroup>

		<!-- copy files to a separate directory for each environment and update version number in filenames -->
		<Copy SourceFiles="@(FilesToMove)" DestinationFiles="$(ReleaseDirectory)%(FilesToMove.Environment)\%(FilesToMove.RecursiveDir)$([System.String]::Copy('%(FilesToMove.Filename)').Replace('1.0.0.0',$(BuildVersion)))%(FilesToMove.Extension)" />
		
		<!-- create release directory if it does not exist yet -->
		<MakeDir Directories="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)" Condition=" !Exists('$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)') " />
		
		<!-- transform *.config -->
		<TransformXml Source="$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).config" Destination="$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)%(ConfigsToTransform.Identity).config" Transform="$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).%(ConfigsToTransform.Environment).config" Condition=" Exists('$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).%(ConfigsToTransform.Environment).config') " />

		<!-- rename transformed app.config to *.dll.config or *.exe.config -->
		<PropertyGroup>
			<DllConfigName>%(ProjectsToRelease.Filename).%(ProjectsToRelease.TargetConfigExtension)</DllConfigName>
		</PropertyGroup>
		<ItemGroup>
			<AppConfigToMove Remove="@(AppConfigToMove)" />
			<AppConfigToMove Include="$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)App.config" Condition=" Exists('$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)App.config') ">
				<TargetFile>$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)$(DllConfigName)</TargetFile>
				<TargetFile Condition=" Exists('$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)bin\') ">$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)bin\$(DllConfigName)</TargetFile>
			</AppConfigToMove>
		</ItemGroup>		
		<Copy SourceFiles="%(AppConfigToMove.FullPath)" DestinationFiles="%(AppConfigToMove.TargetFile)" />
		<Delete Files="%(AppConfigToMove.FullPath)" />
		
		<!-- remove temporary directory -->
		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="$(ReleaseTempDirectory)" Condition=" Exists('$(ReleaseTempDirectory)') " />
		<RemoveDir Directories="$(ReleaseTempDirectory)" />

		<!-- zip release directory and store zip with version number one directory above -->
		<ItemGroup>
			<FilesToZip Remove="@(FilesToZip)" />
			<FilesToZip Include="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)**\*"> 
				<Environment>%(AllEnvironments.Identity)</Environment>
			</FilesToZip>
		</ItemGroup>
			
		<Zip Files="@(FilesToZip)" WorkingDirectory="$(ReleaseDirectory)%(FilesToZip.Environment)\$(RelativeProjectReleaseDirectory)" ZipFileName="$(ReleaseDirectory)%(FilesToZip.Environment)\@(ProjectName)-%(FilesToZip.Environment)-$(BuildVersion).zip" ZipLevel="9" />
					
		<ItemGroup>
			<ReleaseDirectoriesToRemove Include="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(ProjectName)" />
		</ItemGroup>
					
	</Target>

	<Target Name="ReleaseAzure" DependsOnTargets="_BeforeReleaseAzure;BeforeReleaseAzure;CoreReleaseAzure" />
	<Target Name="_BeforeReleaseAzure">
		<ItemGroup>
			<_AzureToRelease Include="$(CSharpSourceDirectory)**\*.$(AzureProjectConventionName).ccproj" />
		</ItemGroup>	
	</Target>
	<Target Name="BeforeReleaseAzure" Inputs="%(_AzureToRelease.RootDir)%(_AzureToRelease.Directory)" Outputs="AlwaysExecute">

		<PropertyGroup>
			<ProjectSourceDirectory>%(_AzureToRelease.RootDir)%(_AzureToRelease.Directory)</ProjectSourceDirectory>
		</PropertyGroup>

		<Message Text="ProjectSourceDirectory : $(ProjectSourceDirectory)" />
		
		<!-- determine all environments from *.*.cscfg -->
		<ItemGroup>
			<AllEnvironmentTransforms Remove="@(AllEnvironmentTransforms)" />
			<AllEnvironmentTransforms Include="$(ProjectSourceDirectory)ServiceConfiguration.*.cscfg" />

			<__AllEnvironments Remove="@(__AllEnvironments)" />
			<__AllEnvironments Include="$(SuitedForAllEnvironmentsDirectoryName)" Condition=" @(AllEnvironmentTransforms) == '' " />
			<__AllEnvironments Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[1])" Condition=" @(AllEnvironmentTransforms) != '' " />
			<_AllEnvironments Remove="@(AllEnvironments)" />
			<AllEnvironments Remove="@(AllEnvironments)" />			
		</ItemGroup>

		<!-- remove duplicates -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(__AllEnvironments)">
            <Output TaskParameter="OutputItems" ItemName="_AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<!--  remove environments that are not in @(ConfigurationsToRelease) -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetCommonItems" InputItems1="@(_AllEnvironments)" InputItems2="@(ConfigurationsToRelease)" Condition=" @(ConfigurationsToRelease) != '' " >
            <Output TaskParameter="OutputItems" ItemName="AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
		<!--  or keep all environments if @(ConfigurationsToRelease) is empty -->
		<ItemGroup>
			<AllEnvironments Include="@(_AllEnvironments)" Condition=" @(ConfigurationsToRelease) == '' " />
			<AllEnvironmentsToRelease Include="@(AllEnvironments)" />
		</ItemGroup>

		<!-- not sure if this works properly if different azure projects have different environment transforms -->
		<ItemGroup>
			<AzureToRelease Include="@(_AzureToRelease)">
				<Environment>%(AllEnvironments.Identity)</Environment>
			</AzureToRelease>
		</ItemGroup>
		
		<Message Text="AzureToRelease : @(AzureToRelease)" />

	</Target>
	<Target Name="CoreReleaseAzure" Inputs="%(AzureToRelease.RootDir)%(AzureToRelease.Directory)%(AzureToRelease.Environment)" Outputs="AlwaysExecute">

		<PropertyGroup>
			<ProjectSourceDirectory>%(AzureToRelease.RootDir)%(AzureToRelease.Directory)</ProjectSourceDirectory>
		</PropertyGroup>

		<ItemGroup>
			<ProjectName Remove="@(ProjectName)" />
		</ItemGroup>
		
		<!-- get project name -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(ProjectSourceDirectory)" String2="\">
			<Output ItemName="ProjectSourceDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(ProjectSourceDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="ProjectName" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>			
			
		<!-- resolve the release directory -->
		<PropertyGroup>
			<ProjectName>@(ProjectName)</ProjectName>
			<RelativeProjectReleaseDirectory>$(ProjectName)\</RelativeProjectReleaseDirectory>
		</PropertyGroup>
		
		<!-- remove bin and obj folders -->
		<ItemGroup>
			<DirectoriesToRemove Remove="@(DirectoriesToRemove)" />
			<DirectoriesToRemove Include="%(AzureToRelease.RelativeDir)obj" />
			<DirectoriesToRemove Include="%(AzureToRelease.RelativeDir)bin" />
		</ItemGroup>

		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToRemove.FullPath)" Condition=" Exists('%(DirectoriesToRemove.FullPath)') " />
		<RemoveDir Directories="@(DirectoriesToRemove)" />

		<!-- convert all relative directory paths to absolute paths -->
		<ConvertToAbsolutePath Paths="$(ReleaseDirectory)%(AzureToRelease.Environment)\">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteReleaseDirectory" />
		</ConvertToAbsolutePath>

		<!-- backup ServiceDefinition.csdef -->
		<Copy SourceFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef" DestinationFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" />

		<!-- transform ServiceDefinition.csdef -->
		<TransformXml Source="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" Destination="$(ProjectSourceDirectory)ServiceDefinition.csdef" Transform="$(ProjectSourceDirectory)ServiceDefinition.%(AzureToRelease.Environment).csdef" Condition=" Exists('$(ProjectSourceDirectory)ServiceDefinition.%(AzureToRelease.Environment).csdef') " />

		<!-- create the azure package, with transformed ServiceDefinition.csdef -->
		<MsBuild Projects="%(AzureToRelease.FullPath)" Targets="Publish" Properties="$(BuildParameters);AbsoluteReleaseDirectory=$(AbsoluteReleaseDirectory)" BuildInParallel="true" />

		<!-- copy the azure package and ServiceConfiguration.cscfg to release directory -->
		<ItemGroup>
			<ReleaseFilesToCopy Remove="@(ReleaseFilesToCopy)" />
			<ReleaseFilesToCopy Include="$(ProjectSourceDirectory)bin\$(Configuration)\app.publish\**\*">
				<Environment>%(AzureToRelease.Environment)</Environment>
			</ReleaseFilesToCopy>
		</ItemGroup>
		<Copy SourceFiles="@(ReleaseFilesToCopy)" DestinationFolder="$(ReleaseDirectory)%(ReleaseFilesToCopy.Environment)\$(RelativeProjectReleaseDirectory)%(ReleaseFilesToCopy.RecursiveDir)" />

		<!-- transform ServiceConfiguration.cscfg for environment -->
		<TransformXml Source="$(ProjectSourceDirectory)ServiceConfiguration.cscfg" Destination="$(ReleaseDirectory)%(AzureToRelease.Environment)\$(RelativeProjectReleaseDirectory)ServiceConfiguration.cscfg" Transform="$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg" Condition=" Exists('$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg') And Exists('$(ProjectSourceDirectory)ServiceConfiguration.cscfg') " />

		<!-- restore ServiceDefinition.csdef -->
		<Copy SourceFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" DestinationFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef" Retries="30" RetryDelayMilliseconds="5000" />

		<!-- delete ServiceDefinition.csdef.original -->
		<Delete Files="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" />
				
		<!-- zip release directory and store zip with version number one directory above -->
		<ItemGroup>
			<ProjectName Remove="@(ProjectName)" />
			<FilesToZip Remove="@(FilesToZip)" />
			<FilesToZip Include="$(ReleaseDirectory)%(ReleaseFilesToCopy.Environment)\$(RelativeProjectReleaseDirectory)%(ReleaseFilesToCopy.RecursiveDir)\**\*"> 
				<Environment>%(ReleaseFilesToCopy.Environment)</Environment>
			</FilesToZip>
		</ItemGroup>
			
		<Zip Files="@(FilesToZip)" WorkingDirectory="$(ReleaseDirectory)%(FilesToZip.Environment)\$(RelativeProjectReleaseDirectory)" ZipFileName="$(ReleaseDirectory)%(FilesToZip.Environment)\$(ProjectName)-%(FilesToZip.Environment)-$(BuildVersion).zip" ZipLevel="9" />
		
		<ItemGroup>
			<ReleaseDirectoriesToRemove Include="$(ReleaseDirectory)%(ReleaseFilesToCopy.Environment)\$(ProjectName)" />
		</ItemGroup>		
		
	</Target>
		
	<Target Name="ReleaseNugetPackages" DependsOnTargets="BeforeReleaseNugetPackage;CoreReleaseNugetPackage" />
	<Target Name="BeforeReleaseNugetPackage">
		<ItemGroup>
			<NuGetToRelease Include="$(CSharpSourceDirectory)**\*.$(NugetProjectConventionName).csproj" />
			<NuGetToRelease Include="$(CSharpSourceDirectory)**\$(NugetProjectToRelease).csproj" Condition=" $(NugetProjectToRelease) != '' " />
		</ItemGroup>	
		
		<Message Text="NuGetToRelease: @(NuGetToRelease)" />
	</Target>
	<Target Name="CoreReleaseNugetPackage" Inputs="%(NuGetToRelease.RootDir)%(NuGetToRelease.Directory)" Outputs="AlwaysExecute">
	
		<!-- create release directory -->
		<MakeDir Directories="$(ReleaseDirectory)$(NuGetDirectoryName)" />
	
		<!-- create the package -->
		<Exec Command="&quot;$(NuGetPath)&quot; pack &quot;%(NuGetToRelease.RelativeDir)%(NuGetToRelease.Filename)%(NuGetToRelease.Extension)&quot; -OutputDirectory $(ReleaseDirectory)$(NuGetDirectoryName) -Version $(BuildVersion) -Properties Configuration=$(Configuration)" />
	
		<ItemGroup>
			<AllEnvironmentsToRelease Include="$(NuGetDirectoryName)" />
		</ItemGroup>
	
	</Target>

	<Target Name="AfterRelease">
	
		<ItemGroup>
			<AllProjectsToRelease Remove="@(AllProjectsToRelease)" />
			<AllProjectsToRelease Include="@(ProjectsToRelease)" />
			<AllProjectsToRelease Include="@(AzureToRelease)" />
			<AllProjectsToRelease Include="@(NuGetToRelease)" />
		</ItemGroup>	
	
		<!-- throw an error if there was nothing to release -->
		<Error Text="There are no projects to be released!" Condition=" @(AllProjectsToRelease) == '' " />
	
		<!-- remove duplicates from AllEnvironmentsToRelease -->
		<Message Text="AllEnvironmentsToRelease: @(AllEnvironmentsToRelease)" />
		
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(AllEnvironmentsToRelease)" Condition=" @(AllEnvironmentsToRelease) != '' ">
            <Output TaskParameter="OutputItems" ItemName="AllEnvironmentsToReleaseCleaned"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
		
		<Message Text="AllEnvironmentsToReleaseCleaned: @(AllEnvironmentsToReleaseCleaned)" />
		
		<ItemGroup>
			<ItemsToCopyToReleaseItemGroup Remove="@(ItemsToCopyToReleaseItemGroup)" />
			<ItemsToCopyToReleaseItemGroup Include="@(ItemsToCopyToRelease)">
				<Environment>%(AllEnvironmentsToReleaseCleaned.Identity)</Environment>
			</ItemsToCopyToReleaseItemGroup>
		</ItemGroup>
		
		<Message Text="ItemsToCopyToReleaseItemGroup: @(ItemsToCopyToReleaseItemGroup)" />
		
		<!-- copy deployment scripts to each environment directory -->
		<Copy SourceFiles="@(ItemsToCopyToReleaseItemGroup)" DestinationFiles="$(ReleaseDirectory)%(ItemsToCopyToReleaseItemGroup.Environment)\needed-for\correct-directory-depth\%(ItemsToCopyToReleaseItemGroup.Identity)" />

		<Message Text="ReleaseDirectoriesToRemove: @(ReleaseDirectoriesToRemove)" />
		
		<!-- remove all release dirs, leaving just the zip files -->
		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(ReleaseDirectoriesToRemove.FullPath)" Condition=" Exists('%(ReleaseDirectoriesToRemove.FullPath)') " />
		<RemoveDir Directories="@(ReleaseDirectoriesToRemove)" Condition=" @(ReleaseDirectoriesToRemove) != '' " />
		
	</Target>	

	<!-- endregion Release targets -->
	
	<!-- beginregion Deploy targets -->
	
	<Target Name="DeployWebsite">
		<ItemGroup>
			<_MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(WebsiteProjectConventionName)*.zip" />		
			<_MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\*$(WebsiteProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
		</ItemGroup>		
	</Target>

	<Target Name="DeployWebService">
		<ItemGroup>
			<_MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(WebServiceProjectConventionName)*.zip" />		
			<_MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\*$(WebServiceProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
		</ItemGroup>		
	</Target>
	
	<Target Name="DeployStaticHtml">
		<ItemGroup>		
			<_MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(StaticHtmlProjectConventionName)*.zip" />		
			<_MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\*$(StaticHtmlProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
			<MSDeployProjectsToDeploy Include="%(_MSDeployProjectsToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_MSDeployProjectsToDeploy.Filename)').Contains($(ProjectToDeploy))) " />
		</ItemGroup>		
	</Target>
	
	<Target Name="CoreMsDeployDeploy" Inputs="%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)" Outputs="AlwaysExecute">
	
		<!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<project filename without extension>;DeployServer=<server - with msdeploy installed - to deploy to>;DeployTargetName=<iis sitename to update>;DeployUsername=<msdeploy user>;DeployPassword=<msdeploy password>' -->
		<Error Condition = " '$(DeployEnvironment)' == '' And Exists('$(ReleaseDirectory)') " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />

		<!-- unzip file first -->
		<Unzip ZipFileName="%(MSDeployProjectsToDeploy.FullPath)" TargetDirectory="%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)$(ProjectToDeploy)" />
				
		<PropertyGroup>
			<MSDeploySkipDirectoryParameter Condition=" $(DeploySkipDirectoryPattern) != '' ">-skip:objectName=dirPath,absolutePath=&quot;$(DeploySkipDirectoryPattern)&quot;</MSDeploySkipDirectoryParameter>
			<MSDeploySkipFileParameter Condition=" $(DeploySkipFilePattern) != '' ">-skip:objectName=filePath,absolutePath=&quot;$(DeploySkipFilePattern)&quot;</MSDeploySkipFileParameter>
			<ProjectReleaseDirectory>%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)$(ProjectToDeploy)</ProjectReleaseDirectory>
		</PropertyGroup>
		
		<Exec Command="&quot;$(MsDeployPath)&quot; -verb:sync -source:contentpath=&quot;$(ProjectReleaseDirectory)&quot; -dest:contentpath=&quot;$(DeployTargetName)&quot;,wmsvc=$(DeployServer),username=$(DeployUsername),password=$(DeployPassword) -allowUntrusted $(MSDeploySkipDirectoryParameter) $(MSDeploySkipFileParameter)" />

		<RemoveDir Directories="$(ProjectReleaseDirectory)" />
		
		<HttpRequest Url="$(DeployWarmupUrl)" FailOnNon2xxResponse="true" Condition=" $(DeployWarmupUrl) != '' " />
	
	</Target>

	<Target Name="DeployConsoleApp" DependsOnTargets="BeforeDeployConsoleApp;CoreDeployConsoleApp" />
	<Target Name="BeforeDeployConsoleApp">
		<ItemGroup>
			<_ConsoleAppsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(ConsoleAppProjectConventionName)*.zip" />	
			<_ConsoleAppsToDeploy Include="$(BaseDirectory)**\*$(ConsoleAppProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />			
			<ConsoleAppsToDeploy Include="%(_ConsoleAppsToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_ConsoleAppsToDeploy.Filename)').Contains($(ProjectToDeploy))) " />
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployConsoleApp" Inputs="%(ConsoleAppsToDeploy.RootDir)%(ConsoleAppsToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
	
		<!-- todo deploy with msdeploy or robocopy -->
	
	</Target>

	<Target Name="DeployService" DependsOnTargets="BeforeDeployService;CoreDeployService" />
	<Target Name="BeforeDeployService">
		<ItemGroup>			
			<_ServicesToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(WindowsServiceProjectConventionName)*.zip" />
			<_ServicesToDeploy Include="$(BaseDirectory)**\*$(WindowsServiceProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />						
			<ServicesToDeploy Include="%(_ServicesToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_ServicesToDeploy.Filename)').Contains($(ProjectToDeploy))) " />
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployService" Inputs="%(ServicesToDeploy.RootDir)%(ServicesToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
	
		<!-- todo deploy with msdeploy or robocopy -->
		<!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<project filename without extension>;DeployServer=<server to deploy to>;DeployDirectory=<path of the service directory within DeployServer>' -->
		<Error Condition = " '$(DeployEnvironment)' == '' " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />

		<!-- unzip file first -->
		<Unzip ZipFileName="%(ServicesToDeploy.FullPath)" TargetDirectory="%(ServicesToDeploy.RootDir)%(ServicesToDeploy.Directory)$(ProjectToDeploy)" />
		
		<PropertyGroup>
			<ServiceName>$(ProjectToDeploy).$(DeployEnvironment)</ServiceName>
			<ProjectReleaseDirectory>%(ServicesToDeploy.RootDir)%(ServicesToDeploy.Directory)$(ProjectToDeploy)</ProjectReleaseDirectory>
		</PropertyGroup>		
		
		<!-- todo create service if it does not exists -->
		<!--
		sc.exe \\$(DeployServer) create $(ServiceName) binPath= &quot;$(DeployDirectory)&quot; start= auto displayname= &quot;$(ProjectToDeploy) ($(DeployEnvironment))&quot;
		
		taskkill /f /IM $(ProjectToDeploy).exe
		-->
		
		<!-- stop the service before updating -->
		<Exec Command="sc.exe \\$(DeployServer) stop $(ServiceName)" ContinueOnError="true" />
		
		<Exec Command="robocopy.exe &quot;$(ProjectReleaseDirectory)&quot; &quot;\\$(DeployServer)\$(DeployDirectory)&quot; /MIR" ContinueOnError="True">
			<Output TaskParameter="ExitCode" PropertyName="ErrorCode" />
		</Exec>
		<Error Condition = " '$(ErrorCode)' != '0' And '$(ErrorCode)' != '1' And '$(ErrorCode)' != '2' And '$(ErrorCode)' != '3' " Text="RoboCopy failed. Examine the log." />
		
		<!-- start the service -->
		<Exec Command="sc.exe \\$(DeployServer) start $(ServiceName)" />
			
	</Target>	

	<Target Name="DeployDatabase" DependsOnTargets="BeforeDeployDatabase;CoreDeployDatabase" />
	<Target Name="BeforeDeployDatabase">
		<ItemGroup>
			<_DatabasesToDeploy Include="$(ReleaseDirectory)\$(SuitedForAllEnvironmentsDirectoryName)\**\*$(DatabaseProjectConventionName)*.zip" />
			<_DatabasesToDeploy Include="$(BaseDirectory)**\*$(DatabaseProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />						
			<DatabasesToDeploy Include="%(_DatabasesToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_DatabasesToDeploy.Filename)').Contains($(ProjectToDeploy))) " />					
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployDatabase" Inputs="%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
		<!-- call targets 'Deploy' with parameters '/p:ProjectToDeploy=<database project filename without extension>;DeployServer=<database-server to deploy to>;DeployTargetName=<database name on the server to update>;DeployUsername=<msdeploy user>;DeployPassword=<msdeploy password>' -->
				
		<!-- unzip file first -->
		<Unzip ZipFileName="%(DatabasesToDeploy.FullPath)" TargetDirectory="%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)$(ProjectToDeploy)" />						

		<PropertyGroup>
			<DacPacPath>%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)$(ProjectToDeploy)$(ProjectToDeploy).dacpac</DacPacPath>
		</PropertyGroup>

		<!-- deploy data-tier application project (http://msdn.microsoft.com/en-us/library/hh550080(v=vs.103).aspx) -->
		<Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="&quot;$(SqlServerRedistPath)\SqlPackage.exe&quot; /Action:Publish /SourceFile:&quot;$(DacPacPath)&quot; /TargetServerName:&quot;$(DeployServer)&quot; /TargetPassword:&quot;$(DeployPassword)&quot; /TargetUser:&quot;$(DeployUsername)&quot; /TargetDatabaseName:&quot;$(DeployTargetName)&quot; /p:AllowIncompatiblePlatform=$(DacDeployAllowIncompatiblePlatform) /p:GenerateSmartDefaults=$(DacDeployGenerateSmartDefaults) /p:BlockOnPossibleDataLoss=$(DacDeployBlockOnPossibleDataLoss)" Condition=" Exists('$(DacPacPath)') " />
		
	</Target>

	<Target Name="DeployAzure" DependsOnTargets="BeforeDeployAzure;CoreDeployAzure" />
	<Target Name="BeforeDeployAzure">
		<ItemGroup>
			<_AzureToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\*$(AzureProjectConventionName)*.zip" />
			<_AzureToDeploy Include="$(BaseDirectory)**\*$(AzureProjectConventionName)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />			
			<AzureToDeploy Include="%(_AzureToDeploy.FullPath)" Condition=" $([System.String]::Copy('%(_AzureToDeploy.Filename)').Contains($(ProjectToDeploy))) " />
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployAzure" Inputs="%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
		<!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<azure project filename without extension>;AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;AzureHostedServiceName=<AzureHostedServiceName>;AzureStorageAccountName=<AzureStorageAccountName>;AzureStorageAccountKey=<AzureStorageAccountKey>;AzureSwapToProductionAfterDeploy=(True|False);AzureRemoveStagingAfterSwap=(True|False);AzureUpgradeInPlace=(True|False)' -->

		<Error Condition = " '$(DeployEnvironment)' == '' And Exists('$(ReleaseDirectory)') " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />
			
		<!-- unzip file first -->
		<Unzip ZipFileName="%(AzureToDeploy.FullPath)" TargetDirectory="%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)$(ProjectToDeploy)" />			
			
		<PropertyGroup>
			<ProjectReleaseDirectory>%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)$(ProjectToDeploy)</ProjectReleaseDirectory>
		</PropertyGroup>
		
		<Error Condition = " !Exists('$(ProjectReleaseDirectory)') " Text="The artifacts at location $(ProjectReleaseDirectory) do not exist. Check if you performed a full release or you project has a config transform for this specific environment." />	
		
		<PropertyGroup>
			<PackageLocation>$(ProjectReleaseDirectory)</PackageLocation>
			<PackageName>$(ProjectToDeploy).cspkg</PackageName>
			<ServiceConfigName>ServiceConfiguration.cscfg</ServiceConfigName>
		</PropertyGroup>
		
		<!-- https://www.windowsazure.com/en-us/develop/net/common-tasks/continuous-delivery/ -->
		<Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureDeployScript) -serviceName $(AzureHostedServiceName) -storageAccountName $(AzureStorageAccountName) -packageLocation $(PackageLocation)\$(PackageName) -cloudConfigLocation $(PackageLocation)\$(ServiceConfigName) -deploymentLabel $(BuildVersion) -certificateFilename $(AzureCertificateFilename) -certificatePassword $(AzureCertificatePassword) -subscriptionid $(AzureSubscriptionID) -swapAfterDeploy $(AzureSwapToProductionAfterDeploy) -deleteStagingAfterSwap $(AzureRemoveStagingAfterSwap) enableDeploymentUpgrade $(AzureUpgradeInPlace)" />	
		
	</Target>

	<Target Name="DeployNugetPackages" DependsOnTargets="BeforeDeployNugetPackage;CoreDeployNugetPackage" />
	<Target Name="BeforeDeployNugetPackage">
		<ItemGroup>
			<NuGetToDeploy Include="$(ReleaseDirectory)$(NuGetDirectoryName)\$(ProjectToDeploy).$(BuildVersion).nupkg" Condition=" Exists('$(ReleaseDirectory)$(NuGetDirectoryName)\$(ProjectToDeploy).$(BuildVersion).nupkg') " />
			<NuGetToDeploy Include="$(BaseDirectory)$(ProjectToDeploy).$(BuildVersion).nupkg" Condition=" !Exists('$(ReleaseDirectory)') And Exists('$(BaseDirectory)$(ProjectToDeploy).$(BuildVersion).nupkg') " />			
		</ItemGroup>	

		<Message Text="NuGetToDeploy: @(NuGetToDeploy)" />
	</Target>
	<Target Name="CoreDeployNugetPackage" Inputs="%(NuGetToDeploy.RootDir)%(NuGetToDeploy.Directory)%(NuGetToDeploy.Filename)" Outputs="AlwaysExecute">
	
		<Error Text="Please provide and api key with parameter NuGetApiKey." Condition=" $(NuGetApiKey) == '' " />
	
		<PropertyGroup>
			<SourceParameter Condition=" '$(NuGetServerUrl)' != '' ">-s $(NuGetServerUrl)</SourceParameter>
		</PropertyGroup>
	
		<!-- create the package -->
		<Exec Command="&quot;$(NuGetPath)&quot; push &quot;%(NuGetToDeploy.RelativeDir)%(NuGetToDeploy.Filename)%(NuGetToDeploy.Extension)&quot; $(NuGetApiKey) $(SourceParameter)" />

	</Target>	
	
	<Target Name="AfterDeploy">

		<ItemGroup>
			<AllProjectsToDeploy Remove="@(AllProjectsToDeploy)" />
			<AllProjectsToDeploy Include="@(MSDeployProjectsToDeploy)" />
			<AllProjectsToDeploy Include="@(ConsoleAppsToDeploy)" />
			<AllProjectsToDeploy Include="@(ServicesToDeploy)" />
			<AllProjectsToDeploy Include="@(DatabasesToDeploy)" />
			<AllProjectsToDeploy Include="@(AzureToDeploy)" />
			<AllProjectsToDeploy Include="@(NuGetToDeploy)" />
		</ItemGroup>

		<!-- throw an error if there was nothing to deploy -->
		<Error Text="There are no projects to be deployed!" Condition=" @(AllProjectsToDeploy) == '' " />

	</Target>
	
	<!-- endregion Deploy targets -->
	
		
	<!-- beginregion Delete targets -->	
	
	<Target Name="DeleteAzure" DependsOnTargets="BeforeDeleteAzure;CoreDeleteAzure" />
	<Target Name="BeforeDeleteAzure">
		<ItemGroup>
			<_AzureToDelete Include="$(SourceDirectory)**\*.$(AzureProjectConventionName).ccproj" />
			<AzureToDelete Include="@(_AzureToDelete)" Condition = " %(_AzureToDelete.Filename) == $(ProjectToDelete) " />
		</ItemGroup>
	</Target>
	<Target Name="CoreDeleteAzure" Inputs="%(AzureToDelete.RootDir)%(AzureToDelete.Directory)" Outputs="AlwaysExecute">
		<!-- call targets 'Delete' with parameters 'ProjectToDelete=<azure project filename without extension>;AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;AzureHostedServiceName=<AzureHostedServiceName>;AzureHostedServiceSlot=<Staging|Production>' -->
		
		<!-- https://www.windowsazure.com/en-us/develop/net/common-tasks/continuous-delivery/ -->
		<Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureDeleteScript) -serviceName $(AzureHostedServiceName) -certificateFilename $(AzureCertificateFilename) -certificatePassword $(AzureCertificatePassword) -subscriptionid $(AzureSubscriptionID) -swapAfterDeploy $(AzureSwapToProductionAfterDeploy) -hostedServiceSlot $(AzureHostedServiceSlot)" />	
		
	</Target>

	<Target Name="AfterDelete">

		<ItemGroup>
			<AllProjectsToDelete Remove="@(AllProjectsToDelete)" />
			<AllProjectsToDelete Include="@(AzureToDelete)" />
		</ItemGroup>

		<PropertyGroup>
			<OneOrMoreProjectsDeleted>False</OneOrMoreProjectsDeleted>
			<OneOrMoreProjectsDeleted Condition=" %(AllProjectsToDelete.Filename) == $(ProjectToDelete) ">True</OneOrMoreProjectsDeleted>
		</PropertyGroup>

		<!-- throw an error if there was nothing to delete -->
		<Error Text="There are no projects to be deleted!" Condition=" $(OneOrMoreProjectsDeleted) == False " />

	</Target>
	
	<!-- endregion Delete targets -->	
	
	<!-- beginregion Analyze targets -->	

	<Target Name="AnalyzeWithFxCop" DependsOnTargets="Build">
	
		<!-- Include all assemblies that are generated from our own projects -->
		<ItemGroup>
			<ProjectsToAnalyze Include="$(SourceDirectory)**\*.csproj" />
		</ItemGroup>
		<ItemGroup>
			<AssembliesToAnalyze Include="%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\$(Configuration)\%(ProjectsToAnalyze.Filename).dll" Condition=" Exists('%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\$(Configuration)\%(ProjectsToAnalyze.Filename).dll') " />
			<AssembliesToAnalyze Include="%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\%(ProjectsToAnalyze.Filename).dll" Condition=" Exists('%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\%(ProjectsToAnalyze.Filename).dll') " />
		</ItemGroup>

		<!-- Run fxcop for AssembliesToAnalyze -->
		<MSBuild.ExtensionPack.CodeQuality.FxCop TaskAction="Analyse" Files="@(AssembliesToAnalyze)" OutputFile="$(CodeAnalysisDirectory)FxCopReport.html" Rules="$(FxCopPath)Rules" FxCopPath="$(FxCopPath)FxCopCmd.exe" ShowSummary="true" LogToConsole="false" ReportXsl="$(FxCopPath)Xml\FxCopReport.xsl" DependencyDirectories="$(BinDirectory)" Condition=" $(SkipAnalysis) == 'False' " />
		
	</Target>
	
	<Target Name="AnalyzeWithSonar" DependsOnTargets="PrepareGlobalProperties;CompileCheck">
				
		<ItemGroup>		
			<_SolutionsToAnalyze Include="$(CSharpSourceDirectory)**\*$(WebsiteProjectConventionName).sln" />
			<_SolutionsToAnalyze Include="$(CSharpSourceDirectory)**\*$(WebServiceProjectConventionName).sln" />
			<_SolutionsToAnalyze Include="$(CSharpSourceDirectory)**\*$(ConsoleAppProjectConventionName).sln" />
			<_SolutionsToAnalyze Include="$(CSharpSourceDirectory)**\*$(WindowsServiceProjectConventionName).sln" />			
			
			<!-- if none of the above exist, look for any solution -->
			<_SolutionsToAnalyze Include="$(CSharpSourceDirectory)**\*.sln" Condition=" @(_SolutionsToAnalyze) == '' " />

			<SolutionsToAnalyze Include="%(_SolutionsToAnalyze.RelativeDir)%(_SolutionsToAnalyze.Filename)%(_SolutionsToAnalyze.Extension)">
				<ProjectName>$(SonarProjectName)</ProjectName>
				<ProjectName Condition=" '$(SonarProjectName)' == '' ">%(_SolutionsToAnalyze.Filename)</ProjectName>
			</SolutionsToAnalyze>        
			
			<AssembliesToExludeFromCoverage Include="$(CSharpSourceDirectory)**\*.$(IntegrationTestsProjectConventionName).csproj" />			
		</ItemGroup>
		
		<PropertyGroup>
			<ExcludeFromCoverage>@(AssembliesToExludeFromCoverage -> '%(Filename)', ',')</ExcludeFromCoverage>
			<SonarConnectionParameters>-D sonar.host.url=&quot;$(SonarHostUrl)&quot; -D sonar.jdbc.driver=&quot;$(SonarDbDriver)&quot; -D sonar.jdbc.url=&quot;$(SonarDbConnectionString)&quot; -D sonar.jdbc.username=&quot;$(SonarDbUsername)&quot; -D sonar.jdbc.password=&quot;$(SonarDbPassword)&quot;</SonarConnectionParameters>
			<SonarConnectionParameters Condition=" $(SonarProfile) != '' ">$(SonarConnectionParameters) -D sonar.profile=&quot;$(SonarProfile)&quot;</SonarConnectionParameters>
		</PropertyGroup>
	
		<Exec Command="&quot;$(SonarRunnerPath)&quot; $(SonarConnectionParameters) -D sonar.projectVersion=$(BuildVersion) -D sonar.projectKey=%(SolutionsToAnalyze.Filename) -D sonar.projectName=%(SolutionsToAnalyze.ProjectName) -D sonar.language=cs -D sonar.dotnet.buildConfigurations=$(Configuration) -D sonar.dotnet.visualstudio.solution.file=%(SolutionsToAnalyze.RelativeDir)%(SolutionsToAnalyze.Filename)%(SolutionsToAnalyze.Extension) -D csharp.sonar.projectBaseDir=%(SolutionsToAnalyze.RelativeDir) -D sonar.gallio.installDirectory=$(GallioPath) -D sonar.gallio.coverage.tool=OpenCover -D sonar.opencover.installDirectory=$(OpenCoverPath) -D sonar.dotnet.visualstudio.testProjectPattern=*$(UnitTestsProjectConventionName)*;*$(IntegrationTestsProjectConventionName)* -D sonar.gallio.coverage.excludes=&quot;$(ExcludeFromCoverage)&quot;" Condition=" $(SkipAnalysis) == 'False' " />
		
	</Target>

	<!-- endregion Analyze targets -->	
	
	<!-- beginregion Optimize targets -->
	
	<Target Name="OptimizeImages">	
		<!-- optimize all jpegs -->
		<ItemGroup>
			<AllJpegFiles Remove="@(AllJpegFiles)" />
			<AllJpegFiles Include="$(SourceDirectory)**\*.jpg" />
			<AllJpegFiles Include="$(SourceDirectory)**\*.jpeg" />
		</ItemGroup>
		<Exec Command="&quot;$(JpegtranPath)&quot; -progressive -optimize &quot;%(AllJpegFiles.FullPath)&quot; &quot;%(AllJpegFiles.FullPath)&quot;" Condition=" @(AllJpegFiles) != '' " />

		<!-- optimize all pngs -->
		<ItemGroup>
			<AllPngFiles Remove="@(AllPngFiles)" />
			<AllPngFiles Include="$(SourceDirectory)**\*.png" />
		</ItemGroup>
		<Exec Command="&quot;$(OptiPngPath)&quot; &quot;%(AllPngFiles.FullPath)&quot;" Condition=" @(AllPngFiles) != '' " />
	</Target>
	
	<!-- endregion Optimize targets -->	
		
	<!-- beginregion Targets to use from outside -->	
	
	<Target Name="Build" DependsOnTargets="PrepareGlobalProperties;Compile" />
    <Target Name="BuildAndRunUnitTests" DependsOnTargets="Build;RunUnitTests" />
    <Target Name="BuildAndRunIntegrationTests" DependsOnTargets="Build;RunIntegrationTests" />
    <Target Name="BuildAndRunAllTests" DependsOnTargets="Build;RunUnitTests;RunIntegrationTests" />

    <Target Name="Minify" DependsOnTargets="PrepareGlobalProperties;MinifyJavaScript;MinifyCss" />
	<Target Name="PublishAssets" DependsOnTargets="PublishFlash" />
	<Target Name="Release" DependsOnTargets="PrepareGlobalProperties;CompileCheck;CreateDirectories;BeforeRelease;Minify;PublishAssets;ReleaseWebsites;ReleaseWebServices;ReleaseConsoleApps;ReleaseServices;ReleaseDatabases;ReleaseWorkers;ReleaseStaticHtml;CoreRelease;ReleaseAzure;ReleaseNugetPackages;AfterRelease" />
	<Target Name="BuildAndRunUnitTestsAndRelease" DependsOnTargets="BeforeRelease;BuildAndRunUnitTests;Release" />

	<Target Name="Deploy" DependsOnTargets="PrepareGlobalProperties;DeployWebsite;DeployWebService;DeployStaticHtml;CoreMsDeployDeploy;DeployConsoleApp;DeployService;DeployDatabase;DeployAzure;DeployNugetPackages;AfterDeploy" />
	<Target Name="Delete" DependsOnTargets="DeleteAzure;AfterDeploy" />

	<!-- endregion Targets to use from outside -->	
	
	<Import Project="targets-repository-specific.msbuild" />

</Project>