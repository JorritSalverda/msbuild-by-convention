
<!-- originally posted at https://github.com/JorritSalverda/msbuild-by-convention/ -->

<Project xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">

	<Import Project="properties-repository-specific.msbuild" />
	
	<!-- beginregion Build targets -->
	
	<Target Name="CreateDirectories">
		<MakeDir Directories="@(DirectoriesToCreate)" />
	</Target>

	<Target Name="Clean" DependsOnTargets="CoreClean;CreateDirectories" />
	<Target Name="CoreClean">
		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToCreate.FullPath)" Condition=" Exists('%(DirectoriesToCreate.FullPath)') " />
		<RemoveDir Directories="@(DirectoriesToCreate)" />
	</Target>

	<Target Name="CopyDependencies">
		<ItemGroup>
			<DependenciesToCopy Include="$(DependencyDirectory)**\*.dll" />
			<DependenciesToCopy Include="$(DependencyDirectory)**\*.xml" />
		</ItemGroup>
		<Copy SourceFiles="@(DependenciesToCopy)" DestinationFolder="$(BinDirectory)" Condition=" @(DependenciesToCopy) != '' " />
	</Target>

	<Target Name="SetAssemblyFileVersion">
		<!-- set correct file version -->
		<ItemGroup>
			<AssemblyInfoFiles Include="$(CSharpSourceDirectory)**\AssemblyInfo.cs" />
		</ItemGroup>
		<Attrib ReadOnly="false" Files="@(AssemblyInfoFiles)" />
	    <FileUpdate Files="@(AssemblyInfoFiles)" Regex="\[\s*assembly\s*:\s*AssemblyFileVersion\s*\(\s*&quot;[\d\.\*]+&quot;\s*\)\s*\]" ReplacementText="[assembly: AssemblyFileVersion(&quot;$(BuildVersion)&quot;)]" Condition=" @(AssemblyInfoFiles) != '' " />
	</Target>

	<Target Name="ReplaceProjectImportStatements" Condition=" Exists('$(VisualStudioTeamdataDir)Microsoft.Data.Schema.SqlTasks.targets') ">
		<!-- look for dbproj files and replace the import statement with one pointing to /build/tools/VisualStudio.v10.0.TeamData -->
		<ItemGroup>
			<DbProjectFiles Remove="@(DbProjectFiles)" />
			<DbProjectFiles Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).dbproj" />
		</ItemGroup>
		<ConvertToAbsolutePath Paths="$(VisualStudioTeamdataDir)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteVisualStudioTeamdataDir" />
		</ConvertToAbsolutePath>
		
		<!-- keep backup of the project file -->
		<Copy SourceFiles="@(DbProjectFiles)" DestinationFiles="%(DbProjectFiles.FullPath).original" /> 
		
		<Attrib ReadOnly="false" Files="@(DbProjectFiles)" />
	    <FileUpdate Files="@(DbProjectFiles)" Regex="\$\(MSBuildExtensionsPath\)\\Microsoft\\VisualStudio\\v10\.0\\TeamData\\" ReplacementText="$(AbsoluteVisualStudioTeamdataDir)" Condition=" @(DbProjectFiles) != '' " />
	</Target>

	<Target Name="Compile" DependsOnTargets="Clean;CopyDependencies;SetAssemblyFileVersion;ReplaceProjectImportStatements;BeforeCompile;CoreCompile;AfterCompile" />
	<Target Name="BeforeCompile">
		<!-- solutions that have a dependency order are specified in properties-repository-specific.msbuild; over here we add all solutions so it's not neccessary to list them all in properties-repository-specific.msbuild -->
		<ItemGroup>
			<SolutionsToBuild Include="$(CSharpSourceDirectory)**\*.sln" />
		</ItemGroup>
	</Target>
    <Target Name="CoreCompile" Inputs="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)" Outputs="NonExistingOutputToTriggerTargetForEverySolution">
		<Error Text="There are no solutions to compile!" Condition=" @(SolutionsToBuild) == '' " />

		<!-- build solution -->
		<ConvertToAbsolutePath Paths="$(BuildToolsDirectory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteBuildToolsDirectory" />
		</ConvertToAbsolutePath>
		<MSBuild Projects="%(SolutionsToBuild.FullPath)" Targets="$(CompileTarget)" Properties="$(BuildParameters);AbsoluteBuildToolsDirectory=$(AbsoluteBuildToolsDirectory)" BuildInParallel="true">
			<Output TaskParameter="TargetOutputs" ItemName="BuildOutput" />
		</MSBuild>

		<!-- compile views for all website and webservice projects -->
		<ItemGroup>
			<ProjectsToBuild Include="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)**\*.$(WebsiteProjectConventionName).csproj" />
			<ProjectsToBuild Include="%(SolutionsToBuild.RootDir)%(SolutionsToBuild.Directory)**\*.$(WebServiceProjectConventionName).csproj" />
		</ItemGroup>

		<!-- remove obj directory from build directory, otherwise aspnetcompiler might fail due to multiple web.configs -->
		<ItemGroup>
			<DirectoriesToRemove Remove="@(DirectoriesToRemove)" />
			<DirectoriesToRemove Include="%(ProjectsToBuild.RelativeDir)obj" />
		</ItemGroup>

		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToRemove.FullPath)" Condition=" Exists('%(DirectoriesToRemove.FullPath)') " />
		<RemoveDir Directories="@(DirectoriesToRemove)" />

		<AspNetCompiler VirtualPath="/" PhysicalPath="%(ProjectsToBuild.RelativeDir)" Condition=" Exists('%(ProjectsToBuild.RelativeDir)Web.config') " />

		<!-- copy output assemblies to build/bin directory -->
        <Copy SourceFiles="@(BuildOutput)" DestinationFolder="$(BinDirectory)" Condition = "%(Extension) == '.dll' Or %(Extension) == '.xml'" />
    </Target>
	<Target Name="AfterCompile">
	
		<!-- restore db project file -->
		<ItemGroup>
			<_OriginalDbProjectFiles Remove="@(_OriginalDbProjectFiles)" />
			<_OriginalDbProjectFiles Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).dbproj.original" />
			
			<OriginalDbProjectFiles Remove="@(OriginalDbProjectFiles)" />
			<OriginalDbProjectFiles Include="%(_OriginalDbProjectFiles.FullPath)">
				<DestinationFile>$([System.String]::Copy('%(_OriginalDbProjectFiles.FullPath)').Replace(".original",""))</DestinationFile>
			</OriginalDbProjectFiles>
		</ItemGroup>
		
		<Message Text="OriginalDbProjectFiles: @(OriginalDbProjectFiles)" />

		<Copy SourceFiles="@(OriginalDbProjectFiles)" DestinationFiles="%(OriginalDbProjectFiles.DestinationFile)" />
		<Delete Files="@(OriginalDbProjectFiles)" />
	
	</Target>	

	<!-- endregion Build targets -->

	<!-- beginregion RunUnitTests targets -->
	
	<Target Name="RunUnitTests" DependsOnTargets="CreateDirectories;CoreRunUnitTests" />
	<Target Name="CoreRunUnitTests">
		<ItemGroup>
			<UnitTestProjects Remove="@(UnitTestProjects)" />
			<UnitTestProjects Include="$(CSharpSourceDirectory)**\*.$(UnitTestsProjectConventionName).csproj" />
		</ItemGroup>

		<ItemGroup>
			<TestAssemblies Remove="@(TestAssemblies)" />
			<TestAssemblies Include="%(UnitTestProjects.RelativeDir)bin\$(Configuration)\%(UnitTestProjects.Filename).dll" />
		</ItemGroup>		

		<!-- filter out test assemblies if nunit.framework.dll is not referenced -->
		<ItemGroup>
			<NunitTestAssemblies Remove="@(NunitTestAssemblies)" />
			<NunitTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)nunit.framework.dll') " />
		</ItemGroup>

		<NUnit Assemblies="@(NunitTestAssemblies)" ToolPath="$(NUnitToolPath)" OutputXmlFile="$(TestResultsDirectory)$(UnitTestsProjectConventionName).Results.xml" DisableShadowCopy="true" Condition=" @(NunitTestAssemblies) != '' " ContinueOnError="$(ContinueOnTestError)" />

		<!-- filter out test assemblies if Machine.Specifications.dll is not referenced -->
		<ItemGroup>
			<MSpecTestAssemblies Remove="@(MSpecTestAssemblies)" />
			<MSpecTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)Machine.Specifications.dll') " />
		</ItemGroup>

		<Exec Command="$(MSpecRunnerPath) --teamcity --html $(TestResultsDirectory) @(MSpecTestAssemblies -> '%(Identity)', ' ')" Condition=" @(MSpecTestAssemblies) != '' " IgnoreExitCode="$(ContinueOnTestError)" />
		
		<!-- filter out test assemblies if Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll is not referenced -->
		<ItemGroup>
			<MSTestTestAssemblies Remove="@(MSTestTestAssemblies)" />
			<MSTestTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)Microsoft.VisualStudio.QualityTools.UnitTestFramework.dll') " />
		</ItemGroup>

		<Delete Files="$(TestResultsDirectory)MsTest.%(MSTestTestAssemblies.Filename).Results.xml" />		
		<Exec Command="$(MSTestRunnerPath) /testcontainer:%(MSTestTestAssemblies.Identity) /resultsfile:$(TestResultsDirectory)MsTest.%(MSTestTestAssemblies.Filename).Results.xml /nologo" Condition=" @(MSTestTestAssemblies) != '' " IgnoreExitCode="$(ContinueOnTestError)" />
		
	</Target>

	<!-- endregion RunUnitTests targets -->
	
	<!-- beginregion RunIntegrationTests targets -->
	
	<Target Name="RunIntegrationTests" DependsOnTargets="CreateDirectories;CoreRunIntegrationTests" />
	<Target Name="CoreRunIntegrationTests">
		<ItemGroup>
			<IntegrationTestProjects Remove="@(IntegrationTestProjects)" />
			<IntegrationTestProjects Include="$(CSharpSourceDirectory)**\*.$(IntegrationTestsProjectConventionName).csproj" />
		</ItemGroup>

		<ItemGroup>
			<TestAssemblies Remove="@(TestAssemblies)" />
			<TestAssemblies Include="%(IntegrationTestProjects.RelativeDir)bin\$(Configuration)\%(IntegrationTestProjects.Filename).dll" />
		</ItemGroup>

		<!-- filter out test assemblies if nunit.framework.dll is not referenced -->
		<ItemGroup>
			<NunitTestAssemblies Remove="@(NunitTestAssemblies)" />
			<NunitTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)nunit.framework.dll') " />
		</ItemGroup>

		<NUnit Assemblies="@(NunitTestAssemblies)" ToolPath="$(NUnitToolPath)" OutputXmlFile="$(TestResultsDirectory)$(IntegrationTestsProjectConventionName).Results.xml" DisableShadowCopy="true" Condition=" @(NunitTestAssemblies) != '' " ContinueOnError="$(ContinueOnTestError)" />

		<!-- filter out test assemblies if Machine.Specifications.dll is not referenced -->
		<ItemGroup>
			<MSpecTestAssemblies Remove="@(MSpecTestAssemblies)" />
			<MSpecTestAssemblies Include="%(TestAssemblies.FullPath)" Condition=" Exists('%(TestAssemblies.RelativeDir)Machine.Specifications.dll') " />
		</ItemGroup>

		<Exec Command="$(MSpecRunnerPath) --teamcity --html $(TestResultsDirectory) @(MSpecTestAssemblies -> '%(Identity)', ' ')" Condition=" @(MSpecTestAssemblies) != '' " IgnoreExitCode="$(ContinueOnTestError)" />
	</Target>

	<!-- endregion RunIntegrationTests targets -->
	
	<!-- beginregion RunJMeterTests targets -->
	
	<Target Name="RunJMeterTests" DependsOnTargets="BeforeRunJMeterTests;CoreRunJMeterTests" />
	<Target Name="BeforeRunJMeterTests">
		<ItemGroup>
			<JMeterTestProjects Remove="@(JMeterTestProjects)" />
			<JMeterTestProjects Include="$(JMeterTestsDirectory)**\*.jmx" />
		</ItemGroup>
	</Target>
	<Target Name="CoreRunJMeterTests" Inputs="%(JMeterTestProjects.FullPath)" Outputs="AlwaysExecute">
		<ConvertToAbsolutePath Paths="$(TestResultsDirectory)%(JMeterTestProjects.Filename).log">
			<Output TaskParameter="AbsolutePaths" PropertyName="JMeterTestLogFileLocation" />
		</ConvertToAbsolutePath>

		<ConvertToAbsolutePath Paths="$(TestResultsDirectory)%(JMeterTestProjects.Filename).jtl">
			<Output TaskParameter="AbsolutePaths" PropertyName="JMeterTestOutputFileLocation" />
		</ConvertToAbsolutePath>

		<!-- start non-gui version of jmeter and pass jmx file, test output location and log file output location -->
		<Exec Command="$(JMeterToolPath) -n -t %(JMeterTestProjects.FullPath) -l $(JMeterTestOutputFileLocation) -j $(JMeterTestLogFileLocation)" Condition=" @(JMeterTestProjects) != '' " />

		<Message Text="##teamcity[importData type='junit' path='$(JMeterTestOutputFileLocation)']" />
	</Target>
	
	<!-- endregion RunJMeterTests targets -->	
	
	<!-- beginregion Release targets -->	

	<Target Name="MinifyJavaScript" DependsOnTargets="BeforeMinifyJavaScript;CoreMinifyJavaScript" />
	<Target Name="BeforeMinifyJavaScript">
		<!-- remove previously minified javascript -->
		<ItemGroup>
			<OldJavaScriptFiles Include="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\*.min.js" />
		</ItemGroup>
		<Delete Files="@(OldJavaScriptFiles)" />

		<ItemGroup>
			<JavaScriptFiles Include="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\**\*.js" Exclude="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\*.min.js" />
			<!-- do not include js files in the js 'root'; put your code in subdirs -->
			<JavaScriptFiles Remove="$(SourceDirectory)**\$(JavascriptDirectoryConventionName)\*.js" />
		</ItemGroup>
	</Target>
	<Target Name="CoreMinifyJavaScript" Inputs="%(JavaScriptFiles.RootDir)%(JavaScriptFiles.Directory)" Outputs="AlwaysExecute">
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="%(JavaScriptFiles.Directory)" String2="\">
			<Output ItemName="JavaScriptOutputDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(JavaScriptOutputDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="JavaScriptSubDirectory" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<JavaScriptCompressorTask
			SourceFiles="@(JavaScriptFiles)"
			OutputFile="%(JavaScriptFiles.RootDir)%(JavaScriptFiles.Directory)..\@(JavaScriptSubDirectory)-$(BuildVersion).min.js"
			ObfuscateJavaScript="True"
			PreserveAllSemicolons="False"
			DisableOptimizations="False"
			EncodingType="UTF8"
			DeleteSourceFiles="false"
			LineBreakPosition="-1"
			LoggingType="Info"
			ThreadCulture="en-US"
			IsEvalIgnored="false"
			/>
	</Target>

	<Target Name="MinifyCss" DependsOnTargets="BeforeMinifyCss;CoreMinifyCss" />
	<Target Name="BeforeMinifyCss">
		<!-- remove previously minified css -->
		<ItemGroup>
			<OldCssFiles Include="$(SourceDirectory)**\$(CssDirectoryConventionName)\**\*.min.css" />
		</ItemGroup>
		<Delete Files="@(OldCssFiles)" />

		<ItemGroup>
			<CssFiles Include="$(SourceDirectory)**\$(CssDirectoryConventionName)\**\*.css" Exclude="$(SourceDirectory)**\$(CssDirectoryConventionName)\**\*.min.css" />
			<!-- do not include css files in the css 'root'; put your code in subdirs (it should only contain stuff like _constants.scss) -->
			<CssFiles Remove="$(SourceDirectory)**\$(CssDirectoryConventionName)\*.css" />
		</ItemGroup>
	</Target>
	<Target Name="CoreMinifyCss" Inputs="%(CssFiles.RootDir)%(CssFiles.Directory)" Outputs="AlwaysExecute">
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="%(CssFiles.Directory)" String2="\">
			<Output ItemName="CssOutputDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(CssOutputDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="CssSubDirectory" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<CssCompressorTask
			SourceFiles="@(CssFiles)"
			OutputFile="%(CssFiles.RootDir)%(CssFiles.Directory)@(CssSubDirectory)-$(BuildVersion).min.css"
			CompressionType="Standard"
			EncodingType="UTF8"
			DeleteSourceFiles="false"
			LineBreakPosition="-1"
			LoggingType="Info"
			/>
	</Target>

	<Target Name="PublishFlash" DependsOnTargets="BeforePublishFlash;CorePublishFlash" />
	<Target Name="BeforePublishFlash">
		<ItemGroup>
			<FlashProjects Include="$(FlashSourceDirectory)**\*.$(FlashProjectDirectoryConventionName)\*" />
			<FlashProjectDirs Include="@(FlashProjects->'%(RelativeDir)')" />
		</ItemGroup>
	</Target>
	<Target Name="CorePublishFlash" Inputs="%(FlashProjectDirs.RootDir)%(FlashProjectDirs.Directory)" Outputs="AlwaysExecute">
		<!-- get rid of the trailing slash -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Replace" OldString="%(FlashProjectDirs.RelativeDir)\" OldValue="\\" NewValue="">
            <Output PropertyName="TrimmedFlashProjectDirectory" TaskParameter="NewString" />
        </MSBuild.ExtensionPack.Framework.TextString>

		<!-- get the last directory name -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(TrimmedFlashProjectDirectory)" String2="\">
			<Output ItemName="FlashProjectDirsParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(FlashProjectDirsParts)">
            <Output TaskParameter="OutputItems" ItemName="FlashProjectDirNameOutput" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
		<PropertyGroup>
			<FlashProjectDirName>@(FlashProjectDirNameOutput)</FlashProjectDirName>
		</PropertyGroup>

		<!-- resolve the same directory tree within SourceDirectory -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Replace" OldString="%(FlashProjectDirs.RelativeDir)" OldValue="$(FlashSourceDirectory)" NewValue="$(CSharpSourceDirectory)">
            <Output PropertyName="RelativeSwfTargetDirectory" TaskParameter="NewString" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<ConvertToAbsolutePath Paths="$(RelativeSwfTargetDirectory)../">
			<Output TaskParameter="AbsolutePaths" PropertyName="SwfTargetDirectory" />
		</ConvertToAbsolutePath>

        <Error Text="Target path $(SwfTargetDirectory) doesn't exists. Put your as3proj file in a similar directory structure inside $(FlashSourceDirectory) as the one in $(CSharpSourceDirectory) to publish to." Condition=" !Exists('$(SwfTargetDirectory)') " />

		<PropertyGroup>
			<SwfTargetFile>$(SwfTargetDirectory)$(FlashProjectDirName).$(BuildVersion).swf</SwfTargetFile>
		</PropertyGroup>

		<Message Text="Publishing %(FlashProjectDirs.RelativeDir) to $(SwfTargetFile)" Importance="high" />

		<ConvertToAbsolutePath Paths="%(FlashProjectDirs.RootDir)%(FlashProjectDirs.Directory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="WorkingDir" />
		</ConvertToAbsolutePath>

		<PropertyGroup>
			<BuildPropertiesFile>%(FlashProjectDirs.RootDir)%(FlashProjectDirs.Directory)build-properties.xml</BuildPropertiesFile>
		</PropertyGroup>

		<!-- fetch flash project specific variables from build-properties.xml -->
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashAutoBuild[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashAutoBuild" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashSrcDirectories/FlashSrcDirectory/text()">
			<Output TaskParameter="Result" ItemName="FlashSrcDirectories" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashLibDirectories/FlashLibDirectory/text()">
			<Output TaskParameter="Result" ItemName="FlashLibDirectories" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashEntryPointFile[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashEntryPointFile" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashBackgroundColor[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashBackgroundColor" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashFrameRate[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashFrameRate" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashWidth[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashWidth" />
		</XmlPeek>
		<XmlPeek XmlInputPath="$(BuildPropertiesFile)" Query="/FlashProperties/FlashHeight[1]/text()">
			<Output TaskParameter="Result" ItemName="FlashHeight" />
		</XmlPeek>

		<!-- remove old versions of published swfs -->
		<ItemGroup>
			<OldSwfsToDelete Remove="@(OldSwfsToDelete)" />
			<OldSwfsToDelete Include="$(SwfTargetDirectory)$(FlashProjectDirName).*.swf" />
		</ItemGroup>

		<Delete Files="@(OldSwfsToDelete)" Condition=" @(FlashAutoBuild) != 'False' " />

		<!-- compile flash and output to SwfTargetFile -->
		<Exec WorkingDirectory="$(WorkingDir)" Command="&quot;$(FlexSdkPath)&quot; -static-link-runtime-shared-libraries=true -library-path+=@(FlashLibDirectories,' -library-path+=') -compiler.incremental=false -debug=false -default-background-color=0x@(FlashBackgroundColor) -default-frame-rate=@(FlashFrameRate) -default-size @(FlashWidth) @(FlashHeight) -source-path=@(FlashSrcDirectories,' -source-path+=') &quot;$(WorkingDir)@(FlashEntryPointFile)&quot; -o &quot;$(SwfTargetFile)&quot; -use-network=true" CustomWarningRegularExpression="Warning|Waarschuwing" CustomErrorRegularExpression="Error|Fout" Condition=" @(FlashAutoBuild) != 'False' " />
	</Target>
	
	<Target Name="BeforeRelease">
		<!-- remove all release artifacts from previous releases -->
		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="$(ReleaseDirectory)" Condition=" Exists('$(ReleaseDirectory)') " />

		<!-- make sure we do a 'rebuild' instead of 'build' -->
		<PropertyGroup>
			<CompileTarget>Clean;Rebuild</CompileTarget>
		</PropertyGroup>
		
		<ItemGroup>
			<AllEnvironmentsToRelease Remove="@(AllEnvironmentsToRelease)" />
		</ItemGroup>	
		
	</Target>

	<Target Name="ReleaseWebsites">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WebsiteProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>True</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern></FilesToCopyForReleasePattern>	
				<ZipDirectory>True</ZipDirectory>				
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseWebServices">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WebServiceProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>True</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern></FilesToCopyForReleasePattern>
				<ZipDirectory>True</ZipDirectory>				
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>
	
	<Target Name="ReleaseStaticHtml">
		<ItemGroup>
			<ProjectsToRelease Include="$(HtmlSourceDirectory)**\*.$(StaticHtmlProjectConventionName)\index.html">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>**\*</FilesToCopyForReleasePattern>				
				<ZipDirectory>True</ZipDirectory>				
			</ProjectsToRelease>			
		</ItemGroup>	
	</Target>	

	<Target Name="ReleaseConsoleApps">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(ConsoleAppProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
				<ZipDirectory>False</ZipDirectory>
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseServices">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WindowsServiceProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
				<ZipDirectory>False</ZipDirectory>				
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseWorkers">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(WorkerProjectConventionName).csproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>bin\$(Configuration)\*</FilesToCopyForReleasePattern>
				<ZipDirectory>False</ZipDirectory>				
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>

	<Target Name="ReleaseDatabases">
		<ItemGroup>
			<ProjectsToRelease Include="$(CSharpSourceDirectory)**\*.$(DatabaseProjectConventionName).dbproj">
				<UseAspNetCompilerForRelease>False</UseAspNetCompilerForRelease>
				<FilesToCopyForReleasePattern>sql\$(Configuration)\*</FilesToCopyForReleasePattern>
				<ZipDirectory>False</ZipDirectory>				
			</ProjectsToRelease>
		</ItemGroup>	
	</Target>
	
	<Target Name="CoreRelease" Inputs="%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)%(ProjectsToRelease.Environment)" Outputs="AlwaysExecute">
		<PropertyGroup>
			<ProjectSourceDirectory>%(ProjectsToRelease.RootDir)%(ProjectsToRelease.Directory)</ProjectSourceDirectory>
			<UseAspNetCompilerForRelease>%(ProjectsToRelease.UseAspNetCompilerForRelease)</UseAspNetCompilerForRelease>
			<FilesToCopyForReleasePattern>%(ProjectsToRelease.FilesToCopyForReleasePattern)</FilesToCopyForReleasePattern>
			<ZipDirectory>%(ProjectsToRelease.ZipDirectory)</ZipDirectory>
		</PropertyGroup>
				
		<!-- resolve the temporary release directory -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Replace" OldString="%(ProjectsToRelease.RelativeDir)" OldValue="$(SourceDirectory)" NewValue="">
            <Output PropertyName="RelativeProjectReleaseDirectory" TaskParameter="NewString" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<ConvertToAbsolutePath Paths="$(ReleaseTempDirectory)$(RelativeProjectReleaseDirectory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="ProjectReleaseDirectory" />
		</ConvertToAbsolutePath>
		
		<!-- if it has a web.config let aspnetcompiler precompile the project  -->
		<AspNetCompiler VirtualPath="/" PhysicalPath="$(ProjectSourceDirectory)" TargetPath="$(ProjectReleaseDirectory)" Updateable="$(CreateUpdateableAspxFilesInRelease)" Condition=" $(UseAspNetCompilerForRelease) == 'True' " />
	
		<!-- otherwise copy the files and dirs defined in FilesToCopyForReleasePattern to the temp folder -->
		<ItemGroup>
			<FilesToCopy Remove="@(FilesToCopy)" />
			<FilesToCopy Include="$(ProjectSourceDirectory)$(FilesToCopyForReleasePattern)" Condition=" $(FilesToCopyForReleasePattern) != '' " />
		</ItemGroup>
		<Copy SourceFiles="@(FilesToCopy)" DestinationFolder="$(ProjectReleaseDirectory)%(FilesToCopy.RecursiveDir)" Condition=" @(FilesToCopy) != '' " />	
		
		<!-- remove project files and web.config transform files from release directory -->
		<ItemGroup>
			<FilesToRemoveFromReleaseDirectory Remove="@(FilesToRemoveFromReleaseDirectory)" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.csproj*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)packages.config" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.settings" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\*.scss" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.*.config" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.snk" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)obj\**\*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)_ReSharper*\**\*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*ReSharper*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.sln" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)**\.svn\**\*" />
			<FilesToRemoveFromReleaseDirectory Include="$(ProjectReleaseDirectory)*.sublime-*" />			
		</ItemGroup>
		<Delete Files="@(FilesToRemoveFromReleaseDirectory)" />

		<!-- update version number inside js and css files -->
		<ItemGroup>
			<AllStaticFiles Remove="@(AllStaticFiles)" />
			<AllStaticFiles Include="$(ProjectReleaseDirectory)$(CssDirectoryConventionName)\**\*.css" />
			<AllStaticFiles Include="$(ProjectReleaseDirectory)$(JavascriptDirectoryConventionName)\**\*.js" />
			<AllStaticFiles Include="$(ProjectReleaseDirectory)**\*.html" />
		</ItemGroup>
		<Attrib ReadOnly="false" Files="@(AllStaticFiles)" />
	    <FileUpdate Files="@(AllStaticFiles)" Regex="1\.0\.0\.0" ReplacementText="$(BuildVersion)" Condition=" @(AllStaticFiles) != '' " />
	
		<!-- remove debug sections -->
		<FileUpdate Files="@(AllStaticFiles)" Regex="(&lt;!-- begin debug --&gt;.*?&lt;!-- end debug --&gt;)|(&lt;!-- begin release)|(end release --&gt;)" ReplacementText=" " Singleline="True" Multiline="True" Condition=" @(AllStaticFiles) != '' " />		
		
		<!-- optimize all jpegs -->
		<ItemGroup>
			<AllJpegFiles Remove="@(AllJpegFiles)" />
			<AllJpegFiles Include="$(ProjectReleaseDirectory)**\*.jpg" />
			<AllJpegFiles Include="$(ProjectReleaseDirectory)**\*.jpeg" />
		</ItemGroup>
		<Exec Command="&quot;$(JpegtranPath)&quot; -progressive -optimize &quot;%(AllJpegFiles.FullPath)&quot; &quot;%(AllJpegFiles.FullPath)&quot;" Condition=" @(AllJpegFiles) != '' And $(OptimizeImages) " />

		<!-- optimize all pngs -->
		<ItemGroup>
			<AllPngFiles Remove="@(AllPngFiles)" />
			<AllPngFiles Include="$(ProjectReleaseDirectory)**\*.png" />
		</ItemGroup>
		<Exec Command="&quot;$(OptiPngPath)&quot; &quot;%(AllPngFiles.FullPath)&quot;" Condition=" @(AllPngFiles) != '' And $(OptimizeImages) " />

		<!-- determine all environments from *.*.config -->
		<ItemGroup>
			<AllEnvironmentTransforms Remove="@(AllEnvironmentTransforms)" />
			<AllEnvironmentTransforms Include="$(ProjectSourceDirectory)*.*.config" />

			<__AllEnvironments Remove="@(__AllEnvironments)" />
			<__AllEnvironments Include="$(SuitedForAllEnvironmentsDirectoryName)" Condition=" @(AllEnvironmentTransforms) == '' " />
			<__AllEnvironments Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[1])" Condition=" @(AllEnvironmentTransforms) != '' " />
			<_AllEnvironments Remove="@(AllEnvironments)" />
			<AllEnvironments Remove="@(AllEnvironments)" />
			
			<_AllConfigsWithTransforms Remove="@(_AllConfigsWithTransforms)" />
			<_AllConfigsWithTransforms Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[0])" Condition=" @(AllEnvironmentTransforms) != '' " />
			<AllConfigsWithTransforms Remove="@(AllConfigsWithTransforms)" />
		</ItemGroup>
		
		<!-- remove duplicates -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(__AllEnvironments)">
            <Output TaskParameter="OutputItems" ItemName="_AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(_AllConfigsWithTransforms)" Condition=" @(_AllConfigsWithTransforms) != '' ">
            <Output TaskParameter="OutputItems" ItemName="AllConfigsWithTransforms"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<!--  remove environments that are not in @(ConfigurationsToRelease) -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetCommonItems" InputItems1="@(_AllEnvironments)" InputItems2="@(ConfigurationsToRelease)" Condition=" @(ConfigurationsToRelease) != '' " >
            <Output TaskParameter="OutputItems" ItemName="AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
		<!--  or keep all environments if @(ConfigurationsToRelease) is empty -->
		<ItemGroup>
			<AllEnvironments Include="@(_AllEnvironments)" Condition=" @(ConfigurationsToRelease) == '' " />
			<AllEnvironmentsToRelease Include="@(AllEnvironments)" />
		</ItemGroup>

		<ItemGroup>
			<ConfigsToTransform Remove="@(ConfigsToTransform)" />
			<ConfigsToTransform Include="@(AllConfigsWithTransforms)">
				<Environment>%(AllEnvironments.Identity)</Environment>
			</ConfigsToTransform>
		</ItemGroup>

		<!-- copy everything from temp directory to release directory and then remove temp directory; this is to ensure no empty directories end up in the release -->
		<ItemGroup>
			<FilesToMove Remove="@(FilesToMove)" />
			<FilesToMove Include="$(ReleaseTempDirectory)**">
				<Environment>%(AllEnvironments.Identity)</Environment>
			</FilesToMove>
		</ItemGroup>

		<!-- copy files to a separate directory for each environment and update version number in filenames -->
		<Copy SourceFiles="@(FilesToMove)" DestinationFiles="$(ReleaseDirectory)%(FilesToMove.Environment)\%(FilesToMove.RecursiveDir)$([System.String]::Copy('%(FilesToMove.Filename)').Replace('1.0.0.0',$(BuildVersion)))%(FilesToMove.Extension)" />
		
		<!-- create release directory if it does not exist yet -->
		<MakeDir Directories="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)" Condition=" !Exists('$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)') " />
		
		<!-- transform *.config -->
		<TransformXml Source="$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).config" Destination="$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)\%(ConfigsToTransform.Identity).config" Transform="$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).%(ConfigsToTransform.Environment).config" Condition=" Exists('$(ProjectSourceDirectory)%(ConfigsToTransform.Identity).%(ConfigsToTransform.Environment).config') " />

		<!-- rename transformed app.config to *.dll.config -->
		<PropertyGroup>
			<DllConfigName>%(ProjectsToRelease.Filename).dll.config</DllConfigName>
		</PropertyGroup>
		<ItemGroup>
			<AppConfigToMove Remove="@(AppConfigToMove)" />
			<AppConfigToMove Include="$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)App.config" Condition=" Exists('$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)App.config') ">
				<TargetFile>$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)$(DllConfigName)</TargetFile>
				<TargetFile Condition=" Exists('$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)bin\') ">$(ReleaseDirectory)%(ConfigsToTransform.Environment)\$(RelativeProjectReleaseDirectory)bin\$(DllConfigName)</TargetFile>
			</AppConfigToMove>
		</ItemGroup>		
		<Copy SourceFiles="%(AppConfigToMove.FullPath)" DestinationFiles="%(AppConfigToMove.TargetFile)" />
		<Delete Files="%(AppConfigToMove.FullPath)" />
		
		<!-- remove temporary directory -->
		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="$(ReleaseTempDirectory)" Condition=" Exists('$(ReleaseTempDirectory)') " />
		<RemoveDir Directories="$(ReleaseTempDirectory)" />

		<!-- zip release directory and store zip with version number one directory above -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Split" String1="$(ProjectSourceDirectory)" String2="\">
			<Output ItemName="ProjectSourceDirectoryParts" TaskParameter="Strings" />
        </MSBuild.ExtensionPack.Framework.TextString>
		<MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetLastItem" InputItems1="@(ProjectSourceDirectoryParts)">
            <Output TaskParameter="OutputItems" ItemName="ProjectName" />
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>	
	
		<ItemGroup>
			<FilesToZip Remove="@(FilesToZip)" />
			<FilesToZip Include="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)\**\*" /> 
		</ItemGroup>
		
		<Zip Files="@(FilesToZip)" WorkingDirectory="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)" ZipFileName="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)\..\@(ProjectName)-$(BuildVersion).zip" ZipLevel="9" Condition=" $(ZipDirectory) == 'True' " />
		
		<RemoveDir Directories="$(ReleaseDirectory)%(AllEnvironments.Identity)\$(RelativeProjectReleaseDirectory)" Condition=" $(ZipDirectory) == 'True' " />
		
	</Target>

	<Target Name="ReleaseAzure" DependsOnTargets="_BeforeReleaseAzure;BeforeReleaseAzure;CoreReleaseAzure" />
	<Target Name="_BeforeReleaseAzure">
		<ItemGroup>
			<_AzureToRelease Include="$(CSharpSourceDirectory)**\*.$(AzureProjectConventionName).ccproj" />
		</ItemGroup>	
	</Target>
	<Target Name="BeforeReleaseAzure" Inputs="%(_AzureToRelease.RootDir)%(_AzureToRelease.Directory)" Outputs="AlwaysExecute">

		<PropertyGroup>
			<ProjectSourceDirectory>%(_AzureToRelease.RootDir)%(_AzureToRelease.Directory)</ProjectSourceDirectory>
		</PropertyGroup>

		<Message Text="ProjectSourceDirectory : $(ProjectSourceDirectory)" />
		
		<!-- determine all environments from *.*.cscfg -->
		<ItemGroup>
			<AllEnvironmentTransforms Remove="@(AllEnvironmentTransforms)" />
			<AllEnvironmentTransforms Include="$(ProjectSourceDirectory)ServiceConfiguration.*.cscfg" />

			<__AllEnvironments Remove="@(__AllEnvironments)" />
			<__AllEnvironments Include="$(SuitedForAllEnvironmentsDirectoryName)" Condition=" @(AllEnvironmentTransforms) == '' " />
			<__AllEnvironments Include="$([System.String]::Copy('%(AllEnvironmentTransforms.Filename)').Split('.')[1])" Condition=" @(AllEnvironmentTransforms) != '' " />
			<_AllEnvironments Remove="@(AllEnvironments)" />
			<AllEnvironments Remove="@(AllEnvironments)" />			
		</ItemGroup>

		<!-- remove duplicates -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(__AllEnvironments)">
            <Output TaskParameter="OutputItems" ItemName="_AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<!--  remove environments that are not in @(ConfigurationsToRelease) -->
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="GetCommonItems" InputItems1="@(_AllEnvironments)" InputItems2="@(ConfigurationsToRelease)" Condition=" @(ConfigurationsToRelease) != '' " >
            <Output TaskParameter="OutputItems" ItemName="AllEnvironments"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>
		<!--  or keep all environments if @(ConfigurationsToRelease) is empty -->
		<ItemGroup>
			<AllEnvironments Include="@(_AllEnvironments)" Condition=" @(ConfigurationsToRelease) == '' " />
			<AllEnvironmentsToRelease Include="@(AllEnvironments)" />
		</ItemGroup>

		<!-- not sure if this works properly if different azure projects have different environment transforms -->
		<ItemGroup>
			<AzureToRelease Include="@(_AzureToRelease)">
				<Environment>%(AllEnvironments.Identity)</Environment>
			</AzureToRelease>
		</ItemGroup>
		
		<Message Text="AzureToRelease : @(AzureToRelease)" />

	</Target>
	<Target Name="CoreReleaseAzure" Inputs="%(AzureToRelease.RootDir)%(AzureToRelease.Directory)%(AzureToRelease.Environment)" Outputs="AlwaysExecute">

		<PropertyGroup>
			<ProjectSourceDirectory>%(AzureToRelease.RootDir)%(AzureToRelease.Directory)</ProjectSourceDirectory>
		</PropertyGroup>

		<!-- resolve the release directory -->
		<MSBuild.ExtensionPack.Framework.TextString TaskAction="Replace" OldString="%(AzureToRelease.RelativeDir)" OldValue="$(SourceDirectory)" NewValue="">
			<Output PropertyName="RelativeProjectReleaseDirectory" TaskParameter="NewString" />
		</MSBuild.ExtensionPack.Framework.TextString>

		<!-- remove bin and obj folders -->
		<ItemGroup>
			<DirectoriesToRemove Remove="@(DirectoriesToRemove)" />
			<DirectoriesToRemove Include="%(AzureToRelease.RelativeDir)obj" />
			<DirectoriesToRemove Include="%(AzureToRelease.RelativeDir)bin" />
		</ItemGroup>

		<MSBuild.ExtensionPack.FileSystem.Folder TaskAction="RemoveContent" Path="%(DirectoriesToRemove.FullPath)" Condition=" Exists('%(DirectoriesToRemove.FullPath)') " />
		<RemoveDir Directories="@(DirectoriesToRemove)" />

		<!-- convert all relative directory paths to absolute paths -->
		<ConvertToAbsolutePath Paths="$(SourceDirectory)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteSourceDirectory" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(ReleaseDirectory)%(AzureToRelease.Environment)\">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteReleaseDirectory" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(CloudExtensionsDir)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteCloudExtensionsDir" />
		</ConvertToAbsolutePath>
		<ConvertToAbsolutePath Paths="$(ExtensionTasksPath)">
			<Output TaskParameter="AbsolutePaths" PropertyName="AbsoluteExtensionTasksPath" />
		</ConvertToAbsolutePath>

		<!-- backup ServiceDefinition.csdef -->
		<Copy SourceFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef" DestinationFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" />

		<!-- transform ServiceDefinition.csdef -->
		<TransformXml Source="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" Destination="$(ProjectSourceDirectory)ServiceDefinition.csdef" Transform="$(ProjectSourceDirectory)ServiceDefinition.%(AzureToRelease.Environment).csdef" Condition=" Exists('$(ProjectSourceDirectory)ServiceDefinition.%(AzureToRelease.Environment).csdef') " />

		<!-- create the azure package, with transformed ServiceDefinition.csdef -->
		<MsBuild Projects="%(AzureToRelease.FullPath)" Targets="Publish" Properties="$(BuildParameters);CloudExtensionsDir=$(AbsoluteCloudExtensionsDir);AbsoluteExtensionTasksPath=$(AbsoluteExtensionTasksPath);AbsoluteSourceDirectory=$(AbsoluteSourceDirectory);AbsoluteReleaseDirectory=$(AbsoluteReleaseDirectory)"  BuildInParallel="true" />

		<!-- copy the azure package and ServiceConfiguration.cscfg to release directory -->
		<ItemGroup>
			<ReleaseFilesToCopy Remove="@(ReleaseFilesToCopy)" />
			<ReleaseFilesToCopy Include="$(ProjectSourceDirectory)bin\$(Configuration)\app.publish\**\*">
				<Environment>%(AzureToRelease.Environment)</Environment>
			</ReleaseFilesToCopy>
		</ItemGroup>
		<Copy SourceFiles="@(ReleaseFilesToCopy)" DestinationFolder="$(ReleaseDirectory)%(ReleaseFilesToCopy.Environment)\$(RelativeProjectReleaseDirectory)%(ReleaseFilesToCopy.RecursiveDir)" />

		<!-- transform ServiceConfiguration.cscfg for environment -->
		<TransformXml Source="$(ProjectSourceDirectory)ServiceConfiguration.cscfg" Destination="$(ReleaseDirectory)%(AzureToRelease.Environment)\$(RelativeProjectReleaseDirectory)ServiceConfiguration.cscfg" Transform="$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg" Condition=" Exists('$(ProjectSourceDirectory)ServiceConfiguration.%(AzureToRelease.Environment).cscfg') And Exists('$(ProjectSourceDirectory)ServiceConfiguration.cscfg') " />

		<!-- restore ServiceDefinition.csdef -->
		<Copy SourceFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" DestinationFiles="$(ProjectSourceDirectory)ServiceDefinition.csdef" Retries="30" RetryDelayMilliseconds="5000" />

		<!-- delete ServiceDefinition.csdef.original -->
		<Delete Files="$(ProjectSourceDirectory)ServiceDefinition.csdef.original" />

	</Target>

	<Target Name="AfterRelease">
	
		<ItemGroup>
			<AllProjectsToRelease Remove="@(AllProjectsToRelease)" />
			<AllProjectsToRelease Include="@(ProjectsToRelease)" />
			<AllProjectsToRelease Include="@(AzureToRelease)" />
		</ItemGroup>	
	
		<!-- throw an error if there was nothing to release -->
		<Error Text="There are no projects to be released!" Condition=" @(AllProjectsToRelease) == '' " />
				
		<!-- remove duplicates from AllEnvironmentsToRelease -->
		<Message Text="AllEnvironmentsToRelease: @(AllEnvironmentsToRelease)" />
		
        <MSBuild.ExtensionPack.Framework.MsBuildHelper TaskAction="RemoveDuplicateFiles" InputItems1="@(AllEnvironmentsToRelease)" Condition=" @(AllEnvironmentsToRelease) != '' ">
            <Output TaskParameter="OutputItems" ItemName="AllEnvironmentsToReleaseCleaned"/>
        </MSBuild.ExtensionPack.Framework.MsBuildHelper>

		<Message Text="AllEnvironmentsToReleaseCleaned: @(AllEnvironmentsToReleaseCleaned)" />
		
		<ItemGroup>
			<ItemsToCopyToReleaseItemGroup Remove="@(ItemsToCopyToReleaseItemGroup)" />
			<ItemsToCopyToReleaseItemGroup Include="@(ItemsToCopyToRelease)">
				<Environment>%(AllEnvironmentsToReleaseCleaned.Identity)</Environment>
			</ItemsToCopyToReleaseItemGroup>
		</ItemGroup>
		
		<Message Text="ItemsToCopyToReleaseItemGroup: @(ItemsToCopyToReleaseItemGroup)" />
				
		<!-- copy deployment scripts to each environment directory -->
		<Copy SourceFiles="@(ItemsToCopyToReleaseItemGroup)" DestinationFiles="$(ReleaseDirectory)%(ItemsToCopyToReleaseItemGroup.Environment)\needed-for\correct-directory-depth\%(ItemsToCopyToReleaseItemGroup.Identity)" />

	</Target>	

	<!-- endregion Release targets -->
	
	<!-- beginregion Deploy targets -->
	
	<Target Name="DeployWebsite">
		<ItemGroup>
			<MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\$(ProjectToDeploy)*.zip" />		
			<MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\$(ProjectToDeploy)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
		</ItemGroup>		
	</Target>

	<Target Name="DeployWebService">
		<ItemGroup>
			<MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\$(ProjectToDeploy)*.zip" />		
			<MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\$(ProjectToDeploy)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
		</ItemGroup>		
	</Target>

	<Target Name="DeployWebService">
		<ItemGroup>
			<MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\$(ProjectToDeploy)*.zip" />		
			<MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\$(ProjectToDeploy)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
		</ItemGroup>		
	</Target>
	
	<Target Name="DeployStaticHtml">
		<ItemGroup>
			<MSDeployProjectsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\$(ProjectToDeploy)*.zip" />		
			<MSDeployProjectsToDeploy Include="$(BaseDirectory)\**\$(ProjectToDeploy)*.zip" Condition=" !Exists('$(ReleaseDirectory)') " />		
		</ItemGroup>		
	</Target>
	
	<Target Name="CoreMsDeployDeploy" Inputs="%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)" Outputs="AlwaysExecute">
	
		<!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<project filename without extension>;DeployServer=<server - with msdeploy installed - to deploy to>;DeployTargetName=<iis sitename to update>;DeployUsername=<msdeploy user>;DeployPassword=<msdeploy password>' -->

		<Error Condition = " '$(DeployEnvironment)' == '' And Exists('$(ReleaseDirectory)') " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />

		<!-- unzip file first -->
		<Unzip ZipFileName="%(MSDeployProjectsToDeploy.FullPath)" TargetDirectory="%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)$(ProjectToDeploy)" />
				
		<PropertyGroup>
			<MSDeploySkipDirectoryParameter Condition=" $(DeploySkipDirectoryPattern) != '' ">-skip:objectName=dirPath,absolutePath=&quot;$(DeploySkipDirectoryPattern)&quot;</MSDeploySkipDirectoryParameter>
			<MSDeploySkipFileParameter Condition=" $(DeploySkipFilePattern) != '' ">-skip:objectName=filePath,absolutePath=&quot;$(DeploySkipFilePattern)&quot;</MSDeploySkipFileParameter>
			<ProjectReleaseDirectory>%(MSDeployProjectsToDeploy.RootDir)%(MSDeployProjectsToDeploy.Directory)$(ProjectToDeploy)</ProjectReleaseDirectory>
		</PropertyGroup>
		
		<Exec Command="&quot;$(MsDeployPath)&quot; -verb:sync -source:contentpath=&quot;$(ProjectReleaseDirectory)&quot; -dest:contentpath=&quot;$(DeployTargetName)&quot;,wmsvc=$(DeployServer),username=$(DeployUsername),password=$(DeployPassword) -allowUntrusted $(MSDeploySkipDirectoryParameter) $(MSDeploySkipFileParameter)" />

		<RemoveDir Directories="$(ProjectReleaseDirectory)" />
		
		<HttpRequest Url="$(DeployWarmupUrl)" FailOnNon2xxResponse="true" Condition=" $(DeployWarmupUrl) != '' " />
	
	</Target>

	<Target Name="DeployConsoleApp" DependsOnTargets="BeforeDeployConsoleApp;CoreDeployConsoleApp" />
	<Target Name="BeforeDeployConsoleApp">
		<ItemGroup>
			<ConsoleAppsToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\$(ProjectToDeploy)\*.config" />	
			<ConsoleAppsToDeploy Include="$(BaseDirectory)**\$(ProjectToDeploy)\*.config" Condition=" !Exists('$(ReleaseDirectory)') " />			
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployConsoleApp" Inputs="%(ConsoleAppsToDeploy.RootDir)%(ConsoleAppsToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
	
		<!-- todo deploy with msdeploy or robocopy -->
	
	</Target>

	<Target Name="DeployService" DependsOnTargets="BeforeDeployService;CoreDeployService" />
	<Target Name="BeforeDeployService">
		<ItemGroup>			
			<ServicesToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\$(ProjectToDeploy)\*.config" />
			<ServicesToDeploy Include="$(BaseDirectory)**\$(ProjectToDeploy)\*.config" Condition=" !Exists('$(ReleaseDirectory)') " />						
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployService" Inputs="%(ServicesToDeploy.RootDir)%(ServicesToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
	
		<!-- todo deploy with msdeploy or robocopy -->
	
	</Target>	

	<Target Name="DeployDatabase" DependsOnTargets="BeforeDeployDatabase;CoreDeployDatabase" />
	<Target Name="BeforeDeployDatabase">
		<ItemGroup>
			<DatabasesToDeploy Include="$(ReleaseDirectory)\$(SuitedForAllEnvironmentsDirectoryName)\**\$(ProjectToDeploy).dbschema" />			
			<DatabasesToDeploy Include="$(BaseDirectory)**\$(ProjectToDeploy).dbschema" Condition=" !Exists('$(ReleaseDirectory)') " />						
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployDatabase" Inputs="%(DatabasesToDeploy.RootDir)%(DatabasesToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
		<!-- call targets 'Deploy' with parameters '/p:ProjectToDeploy=<database project filename without extension>;DeployServer=<database-server to deploy to>;DeployTargetName=<database name on the server to update>;DeployUsername=<msdeploy user>;DeployPassword=<msdeploy password>' -->
				
		<PropertyGroup>
			<DbSchemaPath>%(DatabasesToDeploy.FullPath)</DbSchemaPath>
		</PropertyGroup>

		<!-- deploy vs2010 database project -->
		<Exec Command="&quot;$(DbDeployPath)&quot; /a:Deploy /dsp:Sql /dd+ /model:&quot;$(DbSchemaPath)&quot; /cs:&quot;Server=$(DeployServer);User=$(DeployUsername);Password=$(DeployPassword);Pooling=false&quot; /p:TargetDatabase=&quot;$(DeployTargetName)&quot;" Condition=" Exists('$(DbSchemaPath)') " />

	</Target>
	
	<Target Name="DeployDataTierApplication" DependsOnTargets="BeforeDeployDataTierApplication;CoreDeployDataTierApplication" />
	<Target Name="BeforeDeployDataTierApplication">
		<ItemGroup>
			<DataTierApplicationsToDeploy Include="$(ReleaseDirectory)\$(SuitedForAllEnvironmentsDirectoryName)\**\$(ProjectToDeploy).dacpac" />
			<DataTierApplicationsToDeploy Include="$(BaseDirectory)**\$(ProjectToDeploy).dacpac" Condition=" !Exists('$(ReleaseDirectory)') " />
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployDataTierApplication" Inputs="%(DataTierApplicationsToDeploy.RootDir)%(DataTierApplicationsToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
		<!-- call targets 'Deploy' with parameters '/p:ProjectToDeploy=<database project filename without extension>;DeployServer=<database-server to deploy to>;DeployTargetName=<database name on the server to update>;DeployUsername=<msdeploy user>;DeployPassword=<msdeploy password>' -->
				
		<PropertyGroup>
			<DacPacPath>%(DataTierApplicationsToDeploy.FullPath)</DacPacPath>
		</PropertyGroup>

		<!-- deploy data-tier application project -->
		<Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="&quot;$(SqlPowershellPath)&quot; -f &quot;$(DacDeployScript)&quot; &quot;$(DacPacPath)&quot; &quot;$(DeployServer)&quot; &quot;$(DeployUsername)&quot; &quot;$(DeployPassword)&quot; &quot;$(DeployTargetName)&quot;" Condition=" Exists('$(DacPacPath)') " CustomErrorRegularExpression="^[Exception^]" />

	</Target>	

	<Target Name="DeployAzure" DependsOnTargets="BeforeDeployAzure;CoreDeployAzure" />
	<Target Name="BeforeDeployAzure">
		<ItemGroup>
			<AzureToDeploy Include="$(ReleaseDirectory)\$(DeployEnvironment)\**\$(ProjectToDeploy).cspkg" />
			<AzureToDeploy Include="$(BaseDirectory)**\$(ProjectToDeploy).cspkg" Condition=" !Exists('$(ReleaseDirectory)') " />
		</ItemGroup>
	</Target>
	<Target Name="CoreDeployAzure" Inputs="%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)" Outputs="NonExistingOutputToTriggerTargetForEveryProject">
		<!-- call targets 'Deploy' with parameters '/p:DeployEnvironment=<environment to deploy to>;ProjectToDeploy=<azure project filename without extension>;AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;AzureHostedServiceName=<AzureHostedServiceName>;AzureStorageAccountName=<AzureStorageAccountName>;AzureStorageAccountKey=<AzureStorageAccountKey>;AzureSwapToProductionAfterDeploy=(True|False);AzureRemoveStagingAfterSwap=(True|False);AzureDisallowMultipleActiveInstances=(True|False)' -->

		<Error Condition = " '$(DeployEnvironment)' == '' And Exists('$(ReleaseDirectory)') " Text="Please set parameter DeployEnvironment to select the proper artifacts to deploy." />
			
		<PropertyGroup>
			<ProjectReleaseDirectory>%(AzureToDeploy.RootDir)%(AzureToDeploy.Directory)</ProjectReleaseDirectory>
		</PropertyGroup>
		
		<Error Condition = " !Exists('$(ProjectReleaseDirectory)') " Text="The artifacts at location $(ProjectReleaseDirectory) do not exist. Check if you performed a full release or you project has a config transform for this specific environment." />	
		
		<PropertyGroup>
			<PackageLocation>$(ProjectReleaseDirectory)</PackageLocation>
			<PackageName>%(AzureToDeploy.Filename).cspkg</PackageName>
			<ServiceConfigName>ServiceConfiguration.cscfg</ServiceConfigName>
		</PropertyGroup>

		<!-- http://blogs.msdn.com/b/tomholl/archive/2011/02/23/using-msbuild-to-deploy-to-multiple-windows-azure-environments.aspx -->
		<!-- http://code-inside.de/blog-in/2011/03/14/automatically-deployment-on-windows-azure-with-the-help-of-a-buildserver-via-powershell/ -->
		<Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureDeployScript) $(AzureSubscriptionID) $(AzureCertificateFilename) $(AzureCertificatePassword) $(PackageLocation) $(PackageName) $(ServiceConfigName) $(AzureHostedServiceName) $(AzureStorageAccountName) $(AzureStorageAccountKey) $(BuildVersion) $(AzureSwapToProductionAfterDeploy) $(AzureRemoveStagingAfterSwap) $(AzureDisallowMultipleActiveInstances) " />

	</Target>

	<Target Name="AfterDeploy">

		<ItemGroup>
			<AllProjectsToDeploy Remove="@(AllProjectsToDeploy)" />
			<AllProjectsToDeploy Include="@(MSDeployProjectsToDeploy)" />
			<AllProjectsToDeploy Include="@(ConsoleAppsToDeploy)" />
			<AllProjectsToDeploy Include="@(ServicesToDeploy)" />
			<AllProjectsToDeploy Include="@(DatabasesToDeploy)" />
			<AllProjectsToDeploy Include="@(DataTierApplicationsToDeploy)" />
			<AllProjectsToDeploy Include="@(AzureToDeploy)" />
		</ItemGroup>

		<!-- throw an error if there was nothing to deploy -->
		<Error Text="There are no projects to be deployed!" Condition=" @(AllProjectsToDeploy) == '' " />

	</Target>
	
	<!-- endregion Deploy targets -->
	
		
	<!-- beginregion Delete targets -->	
	
	<Target Name="DeleteAzure" DependsOnTargets="BeforeDeleteAzure;CoreDeleteAzure" />
	<Target Name="BeforeDeleteAzure">
		<ItemGroup>
			<_AzureToDelete Include="$(SourceDirectory)**\*.$(AzureProjectConventionName).ccproj" />
			<AzureToDelete Include="@(_AzureToDelete)" Condition = " %(_AzureToDelete.Filename) == $(ProjectToDelete) " />
		</ItemGroup>
	</Target>
	<Target Name="CoreDeleteAzure" Inputs="%(AzureToDelete.RootDir)%(AzureToDelete.Directory)" Outputs="AlwaysExecute">
		<!-- call targets 'Delete' with parameters 'ProjectToDelete=<azure project filename without extension>;AzureSubscriptionID=<AzureSubscriptionID>;AzureCertificateFilename=<AzureCertificateFilename>;AzureCertificatePassword=<AzureCertificatePassword>;AzureHostedServiceName=<AzureHostedServiceName>;AzureHostedServiceSlot=<Staging|Production>' -->

		<Exec WorkingDirectory="$(MSBuildProjectDirectory)" Command="$(PowershellPath) -f $(AzureDeleteScript) $(AzureSubscriptionID) $(AzureCertificateFilename) $(AzureCertificatePassword) $(AzureHostedServiceName) $(AzureHostedServiceSlot) " />

	</Target>

	<Target Name="AfterDelete">

		<ItemGroup>
			<AllProjectsToDelete Remove="@(AllProjectsToDelete)" />
			<AllProjectsToDelete Include="@(AzureToDelete)" />
		</ItemGroup>

		<PropertyGroup>
			<OneOrMoreProjectsDeleted>False</OneOrMoreProjectsDeleted>
			<OneOrMoreProjectsDeleted Condition=" %(AllProjectsToDelete.Filename) == $(ProjectToDelete) ">True</OneOrMoreProjectsDeleted>
		</PropertyGroup>

		<!-- throw an error if there was nothing to delete -->
		<Error Text="There are no projects to be deleted!" Condition=" $(OneOrMoreProjectsDeleted) == False " />

	</Target>
	
	<!-- endregion Delete targets -->	
	
	<!-- beginregion AnalyzeCode targets -->	

	<Target Name="AnalyzeCode" DependsOnTargets="Build">
		<!-- Include all assemblies that are generated from our own projects -->
		<ItemGroup>
			<ProjectsToAnalyze Include="$(SourceDirectory)**\*.csproj" />
		</ItemGroup>
		<ItemGroup>
			<AssembliesToAnalyze Include="%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\$(Configuration)\%(ProjectsToAnalyze.Filename).dll" Condition=" Exists('%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\$(Configuration)\%(ProjectsToAnalyze.Filename).dll') " />
			<AssembliesToAnalyze Include="%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\%(ProjectsToAnalyze.Filename).dll" Condition=" Exists('%(ProjectsToAnalyze.RootDir)%(ProjectsToAnalyze.Directory)bin\%(ProjectsToAnalyze.Filename).dll') " />
		</ItemGroup>

		<!-- Run fxcop for AssembliesToAnalyze -->
		<MSBuild.ExtensionPack.CodeQuality.FxCop TaskAction="Analyse" Files="@(AssembliesToAnalyze)" OutputFile="$(CodeAnalysisDirectory)FxCopReport.html" Rules="$(FxCopPath)Rules" FxCopPath="$(FxCopPath)FxCopCmd.exe" ShowSummary="true" LogToConsole="false" ReportXsl="$(FxCopPath)Xml\FxCopReport.xsl" DependencyDirectories="$(BinDirectory)" />
	</Target>

	<!-- endregion AnalyzeCode targets -->	
		
	<!-- beginregion Targets to use from outside -->	
	
	<Target Name="Build" DependsOnTargets="Compile" />
    <Target Name="BuildAndRunUnitTests" DependsOnTargets="Build;RunUnitTests" />
    <Target Name="BuildAndRunIntegrationTests" DependsOnTargets="Build;RunIntegrationTests" />
    <Target Name="BuildAndRunAllTests" DependsOnTargets="Build;RunUnitTests;RunIntegrationTests" />

    <Target Name="Minify" DependsOnTargets="MinifyJavaScript;MinifyCss" />
	<Target Name="PublishAssets" DependsOnTargets="PublishFlash" />
	<Target Name="Release" DependsOnTargets="CreateDirectories;BeforeRelease;Minify;PublishAssets;ReleaseWebsites;ReleaseWebServices;ReleaseConsoleApps;ReleaseServices;ReleaseDatabases;ReleaseWorkers;ReleaseStaticHtml;CoreRelease;ReleaseAzure;AfterRelease" />
	<Target Name="BuildAndRunUnitTestsAndRelease" DependsOnTargets="BeforeRelease;BuildAndRunUnitTests;Release" />

	<Target Name="Deploy" DependsOnTargets="DeployWebsite;DeployWebService;DeployStaticHtml;CoreMsDeployDeploy;DeployConsoleApp;DeployService;DeployDatabase;DeployDataTierApplication;DeployAzure;AfterDeploy" />
	<Target Name="Delete" DependsOnTargets="DeleteAzure;AfterDeploy" />

	<!-- endregion Targets to use from outside -->	
	
	<Import Project="targets-repository-specific.msbuild" />

</Project>